<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>Tency的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Tency的博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Tency的博客">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Tency的博客">
  
    <link rel="alternate" href="/atom.xml" title="Tency的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Tency的博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/11/10/hello-world/" class="article-date">
  <time datetime="2019-11-10T14:34:32.454Z" itemprop="datePublished">2019-11-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/10/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/11/10/hello-world/" data-id="ck35ybx6i000dnrh2kmz1wmsm" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-HTTP协议那些事-0" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/09/HTTP协议那些事-0/" class="article-date">
  <time datetime="2019-06-09T08:38:09.000Z" itemprop="datePublished">2019-06-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/京城一灯第二章/">京城一灯第二章</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/09/HTTP协议那些事-0/">HTTP协议那些事</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>参考文章：<a href="https://yuchengkai.cn/docs/cs/#%E7%8A%B6%E6%80%81%E6%9C%BA" target="_blank" rel="noopener">https://yuchengkai.cn/docs/cs/#%E7%8A%B6%E6%80%81%E6%9C%BA</a></strong></p>
<h4 id="了解TCP-IP协议栈"><a href="#了解TCP-IP协议栈" class="headerlink" title="了解TCP/IP协议栈"></a>了解TCP/IP协议栈</h4><p><img src="https://upload-images.jianshu.io/upload_images/7728915-a8293591c901b74c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>左边是ISO/OSI网络体系结构（国际组织的标准规范），右边是TCP/IP协议模型。<br>ISO/OSI网络体系结构把应用层划分得更加细了。</p>
<ul>
<li>应用层<br>为用户提供所需要的各种服务，例如：HTTP、FTP、DNS、SMTP等. </li>
<li>传输层<br>为应用层实体提供端到端的通信功能，保证数据包的顺序传送及数<br>据的完整性。<br>该层定义了两个主要的协议：传输控制协议<strong>（TCP）</strong>和用户数据报协<br>议<strong>（UDP)</strong></li>
<li>网络层<br>主要解决主机到主机的通信问题。<strong>IP协议</strong>是网际互联层最重要的协<br>议。 </li>
<li>网络接口层<br>负责监视数据在主机和网络之间的交换。<h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4></li>
</ul>
<hr>
<h5 id="面向报文"><a href="#面向报文" class="headerlink" title="面向报文"></a>面向报文</h5><p>UDP 是一个面向报文（报文可以理解为一段段的数据）的协议。意思就是 UDP 只是报文的搬运工，不会对报文进行任何拆分和拼接操作。<br>具体来说，<br>在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会<strong>给数据增加一个 UDP 头标识下是 UDP 协议</strong>，然后就传递给网络层了<br>在接收端，网络层将数据传递给传输层，UDP 只<strong>去除 IP 报文头就传递给应用层</strong>，不会任何拼接操作</p>
<h5 id="不可靠性"><a href="#不可靠性" class="headerlink" title="不可靠性"></a>不可靠性</h5><ol>
<li>UDP是无连接的，也就是说通信不需要建立和断开连接</li>
<li>UDP也是不可靠的，收到什么数据就传递什么数据，也不备份数据，也不关心对方到底有没有收到数据。</li>
<li>UDP没有拥塞控制，只会以恒定的速率去发送，这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。<h5 id="高效"><a href="#高效" class="headerlink" title="高效"></a>高效</h5>UDP没有TCP那么复杂，所以头部开销很小，只有八字节，相对于TCP的二十字节要小的多，所以在传输报文的时候是很高效的。<br><img src="https://upload-images.jianshu.io/upload_images/7728915-4a1be24dad2aef33.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>头部包含了下面几个数据。</li>
</ol>
<ul>
<li>两个十六位的端口号，分别为源端口（可选字段）和目标端口</li>
<li>整个数据报文的长度</li>
<li>整个数据报文的检验和（IPv4可选字段）,用于发现头部信息和数据中的错误。<h5 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h5>支持一对多，多对一，多对多，一对一，UDP提供了多播，单播，广播的功能。</li>
</ul>
<h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><hr>
<h5 id="头部"><a href="#头部" class="headerlink" title="头部"></a>头部</h5><p>TCP头部要比UDP复杂的多。<br><img src="https://upload-images.jianshu.io/upload_images/7728915-4a1be24dad2aef33.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>对于TCP来说，以下字段是很重要的。</p>
<ul>
<li>Sequence number，这个序号保证了 TCP 传输的报文都是有序的，对端可以通过序号顺序的拼接报文</li>
<li>Acknowledgement Number，这个序号表示数据接收端期望接收的下一个字节的编号是多少，同时也表示上一个序号的数据已经收到</li>
<li>Window Size，窗口大小，表示还能接收多少字节的数据，用于流量控制</li>
<li><p>标识符</p>
<ul>
<li><p>URG=1：该字段为一表示本数据报的数据部分包含紧急信息，是一个高优先级数据报文，此时紧急指针有效。紧急数据一定位于当前数据包数据部分的最前面，紧急指针标明了紧急数据的尾部。</p>
</li>
<li><p>ACK=1：该字段为一表示确认号字段有效。此外，TCP 还规定在连接建立后传送的所有报文段都必须把 ACK 置为一。</p>
</li>
<li><p>PSH=1：该字段为一表示接收端应该立即将数据 push 给应用层，而不是等到缓冲区满后再提交。</p>
</li>
<li><p>SYN=1：当SYN=1，ACK=0时，表示当前报文段是一个连接请求报文。当SYN=1，ACK=1时，表示当前报文段是一个同意建立连接的应答报文。</p>
</li>
<li><p>FIN=1：该字段为一表示此报文段是一个释放连接的请求报文。</p>
<h5 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h5><p>HTTP 是无连接的，所以作为下层的 TCP 协议也是无连接的，虽然看似 TCP 将两端连接了起来，但是其实只是两端共同维护了一个状态。</p>
</li>
</ul>
</li>
</ul>
<p>TCP 的状态机是很复杂的，并且与建立断开连接时的握手息息相关，接下来就来详细描述下两种握手。</p>
<p>在这之前需要了解一个重要的性能指标 RTT。该指标表示发送端发送数据到接收到对端数据所需的往返时间。</p>
<h6 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h6><p><img src="https://upload-images.jianshu.io/upload_images/7728915-dd952514a175e36d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><strong>你是否有疑惑明明两次握手就可以建立起连接，为什么还需要第三次应答？</strong><br>可以想象如下场景。客户端发送了一个连接请求 A，但是因为网络原因造成了超时，这时 TCP 会启动超时重传的机制再次发送一个连接请求 B。此时请求顺利到达服务端，服务端应答完就建立了请求。如果连接请求 A 在两端关闭后终于抵达了服务端，那么这时服务端会认为客户端又需要建立 TCP 连接，从而应答了该请求并进入 ESTABLISHED 状态。此时客户端其实是 CLOSED 状态，那么就会导致服务端一直等待，造成资源的浪费。</p>
<p>PS：在建立连接中，任意一端掉线，TCP 都会重发 SYN 包，一般会重试五次，在建立连接中可能会遇到 SYN FLOOD 攻击。遇到这种情况你可以选择调低重试次数或者干脆在不能处理的情况下拒绝请求。</p>
<p>######断开链接四次握手<br><img src="https://upload-images.jianshu.io/upload_images/7728915-fcbe00838bb57fcc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><strong>为什么 A 要进入 TIME-WAIT 状态，等待 2MSL 时间后才进入 CLOSED 状态？</strong></p>
<p>为了保证 B 能收到 A 的确认应答。若 A 发完确认应答后直接进入 CLOSED 状态，如果确认应答因为网络问题一直没有到达，那么会造成 B 不能正常关闭。</p>
<h5 id="ARQ"><a href="#ARQ" class="headerlink" title="ARQ"></a>ARQ</h5><p>RQ 协议也就是<strong>超时重传机制</strong>。通过确认和超时机制保证了数据的正确送达，ARQ 协议包含停止等待 ARQ 和连续 ARQ。</p>
<h6 id="停止等待ARQ"><a href="#停止等待ARQ" class="headerlink" title="停止等待ARQ"></a>停止等待ARQ</h6><ul>
<li>正常传输过程<br>只要 A 向 B 发送一段报文，都要<strong>停止发送</strong>并启动一个定时器，等待对端回应，在定时器时间内<strong>接收到对端应答就取消</strong>定时器并发送下一段报文。</li>
<li><p>报文丢失或出错<br>在报文传输的时候如果出现丢包，这时候如果超过定时器设定的时间就会再次发送丢的包直到对端回应，所以每次都需要备份发送的数据。<br>在超时的情况下也  可能出现应答很迟到达，这时 A 端会判断该序号是否已经接收过，如果接收过只需要丢弃应答即可。<br>PS：一般定时器设定的时间都会大于一个 RTT 的平均时间。</p>
</li>
<li><p>ACK 超时或丢失<br>对端传输的应答也可能出现丢失或超时的情况。那么超过定时器时间 A 端照样会重传报文。这时候 B 端收到相同序号的报文会丢弃该报文并重传应答，直到 A 端发送下一个序号的报文。</p>
<p>在超时的情况下也可能出现应答很迟到达，这时 A 端会判断该序号是否已经接收过，如果接收过只需要丢弃应答即可。</p>
<p><strong>这个协议的缺点就是传输效率低，在良好的网络环境下每次发送报文都得等待对端的 ACK</strong></p>
</li>
</ul>
<h6 id="连续ARQ"><a href="#连续ARQ" class="headerlink" title="连续ARQ"></a>连续ARQ</h6><p>在连续 ARQ 中，发送端拥有一个发送窗口，可以在没有收到应答的情况下持续发送窗口内的数据，这样相比停止等待 ARQ 协议来说减少了等待时间，提高了效率。</p>
<ul>
<li>累计确认<br>连续 ARQ 中，接收端会持续不断收到报文。如果和停止等待 ARQ 中接收一个报文就发送一个应答一样，就太浪费资源了。通过累计确认，可以在收到多个报文以后统一回复一个应答报文。报文中的 ACK 可以用来告诉发送端这个序号之前的数据已经全部接收到了，下次请发送这个序号 + 1的数据。</li>
</ul>
<h5 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h5><p>在 TCP 中，两端都维护着窗口：分别为发送端窗口和接收端窗口。</p>
<p>发送端窗口包含已发送但未收到应答的数据和可以发送但是未发送的数据。<br><img src="https://upload-images.jianshu.io/upload_images/7728915-0b36211ab5ce75eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>Sent and Ackownledged(已经发送已经收到应答)<br>Sent and Not Yet Acknowledged(已经发送但没收到应答)<br>Not Sent (还没发送，但是可以发送)<br>发送端窗口的大小是由接收端窗口的大小决定的，<strong>接收方会把当前接收窗口的剩余大小写入应答报文</strong>，发送端根据该值和网络拥塞状况来设定发送窗口的大小，所以发送窗口的大小是不断变化的。<br><strong>当发送端收到应答报文之后，会将窗口进行滑动</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/7728915-ad6b4e9f11897f86.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>滑动窗口实现了流量控制。接收方通过报文告知发送方还可以发送多少数据，从而保证接收方能够来得及接收数据。</p>
<ul>
<li>Zero 窗口<br>在发送报文的过程中，可能会遇到对端出现零窗口的情况。在该情况下，发送端会停止发送数据，并启动 persistent timer 。该定时器会定时发送请求给对端，让对端告知窗口大小。在重试次数超过一定次数后，可能会中断 TCP 链接。</li>
</ul>
<h5 id="拥塞处理"><a href="#拥塞处理" class="headerlink" title="拥塞处理"></a>拥塞处理</h5><p>拥塞处理和流量控制不同，流量控制是作用于接收方，保证接收方来得及接受数据。而<strong>拥塞处理是作用于网络</strong>，防止过多的数据拥塞网络，避免出现网络负载过大的情况。</p>
<p>拥塞处理包括了四个算法，分别为：慢开始，拥塞避免，快速重传，快速恢复</p>
<ul>
<li>慢开始<br>在传输开始时将发送窗口慢慢指数级扩大，从而避免一开始就传输大量数据导致网络拥塞。<br>算法具体步骤如下：</li>
</ul>
<ol>
<li>连接初始设置拥塞窗口（Congestion Window） 为 1 MSS（一个分段的最大数据量）</li>
<li>每过一个 RTT 就将窗口大小乘二</li>
<li>有一个阈值限制，当窗口大小大于阈值时就会启动拥塞避免算法。</li>
</ol>
<ul>
<li><p>拥塞避免<br>拥塞避免算法相比简单点，每过一个 RTT 窗口大小只加一，这样能够避免指数级增长导致网络拥塞，慢慢将大小调整到最佳值。</p>
<p>在传输过程中可能定时器超时的情况，这时候 TCP 会认为网络拥塞了，会马上进行以下步骤：</p>
</li>
</ul>
<ol>
<li>将阈值设为当前拥塞窗口的一半</li>
<li>将拥塞窗口设为 1 MSS</li>
<li>启动拥塞避免算法</li>
</ol>
<ul>
<li>快速重传和快恢复<br>快速重传一般和快恢复一起出现。如果收到三个重复的 ACK，无需等待定时器超时再重发而是启动快速重传。具体算法分为两种：</li>
</ul>
<p><strong>TCP Taho 实现如下</strong></p>
<ol>
<li>将阈值设为当前拥塞窗口的一半</li>
<li>将拥塞窗口设为 1 MSS</li>
<li>重新开始慢开始算法</li>
<li>TCP Reno 实现如下</li>
</ol>
<p><strong>拥塞窗口减半</strong></p>
<ol>
<li>将阈值设为当前拥塞窗口</li>
<li>进入快恢复阶段（重发对端需要的包，一旦收到一个新的 ACK 答复就退出该阶段）</li>
<li>使用拥塞避免算法</li>
</ol>
<h4 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h4><hr>
<p>HTTP协议是无状态协议，不会保存状态</p>
<h5 id="POST和GET的区别"><a href="#POST和GET的区别" class="headerlink" title="POST和GET的区别"></a>POST和GET的区别</h5><p>先看看什么是幂等和副作用。<br>副作用指<strong>对服务器上的资源做改变</strong>，搜索是无副作用的，注册是副作用的。<br>幂等指<strong>发送 M 和 N 次请求（两者不相同且都大于 1），服务器上资源的状态一致</strong>，比如注册 10 个和 11 个帐号是不幂等的，对文章进行更改 10 次和 11 次是幂等的。<br>在应用场景上来说，GET更适合于幂等和无副作用的的场景，例如搜索关键字。POST多用于不幂等和有副作用的场景，例如注册。<br>从技术的角度说：</p>
<ul>
<li>Get 请求能缓存，Post 不能</li>
<li>Post 相对 Get 安全一点点，因为Get 请求都包含在 URL 里，且会被浏览器保存历史纪录，Post 不会，但是在抓包的情况下都是一样的。</li>
<li>Post 可以通过 request body来传输比 Get 更多的数据，Get 没有这个技术</li>
<li>URL有长度限制，会影响 Get 请求，但是这个长度限制是浏览器规定的，不是 RFC 规定的</li>
<li>Post 支持更多的编码类型且不对数据类型限制</li>
</ul>
<h5 id="常见状态码"><a href="#常见状态码" class="headerlink" title="常见状态码"></a>常见状态码</h5><p>   <strong>2XX 成功</strong></p>
<ul>
<li>200 OK，表示从客户端发来的请求在服务器端被正确处理</li>
<li>201 No content，表示请求成功，但响应报文不含实体的主体部分</li>
</ul>
<p><strong>3XX重定向</strong></p>
<ul>
<li>301 moved permanently，永久性重定向，表示资源已被分配了新的 URL</li>
<li>302 found，临时性重定向，表示资源临时被分配了新的 URL</li>
<li>304 not modified 表示服务器允许访问资源,对客户端有缓存情况下服务端的一种响应。(与缓存有关)</li>
</ul>
<p><strong>4XX客户端错误</strong></p>
<ul>
<li>400 bad request，请求报文存在语法错误</li>
<li>403 forbidden，表示对请求资源的访问被服务器拒绝</li>
<li>404 not found ,表示在服务器上找不到请求的资源</li>
</ul>
<p><strong>5XX服务器错误</strong></p>
<ul>
<li>500 internal sever error，表示服务器端在执行请求时发生了错误</li>
<li>501 Not Implemented，表示服务器不支持当前请求所需要的某个功能</li>
<li>503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求</li>
</ul>
<h5 id="浏览器行为与HTTP协议"><a href="#浏览器行为与HTTP协议" class="headerlink" title="浏览器行为与HTTP协议"></a>浏览器行为与HTTP协议</h5><p>处理流程：</p>
<ol>
<li>输入网址并回车</li>
<li>解析域名（DNS解析）DNS数据库根据key请求value</li>
<li>浏览器发送HTTP请求(路由策略)</li>
<li>服务器处理请求</li>
<li>服务器返回HTML请求</li>
<li>浏览器处理HTML页面</li>
<li>继续请求其他资源<br>ps:浏览器会暂时缓存ip地址和网址的关系，不需要再次解析<br>请求和响应的路由路径是在运营商处理<br>运营商广告： 劫持并解析请求URI，在请求的资源中插入一些脚本，就是弹广告了</li>
</ol>
<h5 id="HTTP和HTTPS的主要区别"><a href="#HTTP和HTTPS的主要区别" class="headerlink" title="HTTP和HTTPS的主要区别"></a>HTTP和HTTPS的主要区别</h5><ul>
<li><p>HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。</p>
</li>
<li><p>HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。</p>
</li>
<li><p>HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p>
</li>
<li><p>HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。</p>
</li>
</ul>
<h5 id="HTTP的工作过程"><a href="#HTTP的工作过程" class="headerlink" title="HTTP的工作过程"></a>HTTP的工作过程</h5><p>一次HTTP操作称为一个事务，其操作过程可以分为四步：</p>
<ol>
<li><p>首先客户机与服务器需要建立连接。只要单击某个超级链接，HTTP的工作开始。（DNS，TCP）</p>
</li>
<li><p>建立连接后，客户机<strong>发送一个请求</strong>给服务器，请求方式的格式为：统一资源标识符(URL)、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可能的内容。（HTTP）</p>
</li>
</ol>
<ol start="3">
<li><p>服务器接到请求后，<strong>给予相应的响应信息</strong>，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。 （HTTP）</p>
</li>
<li><p>客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接。<br>如果在以上过程中的某一步出现错误，那么产生错误的信息将返回到客户端，有显示屏输出。对于用户来说，这些过程是由HTTP自己完成的，用户只要用鼠标点击，等待信息显示就可以了。</p>
</li>
</ol>
<h5 id="HTTP请求和响应"><a href="#HTTP请求和响应" class="headerlink" title="HTTP请求和响应"></a>HTTP请求和响应</h5><ul>
<li><p>HTTP请求组成：请求行、消息报头（Request Headers）、请求正文。<br>其中，请求行+消息报头 = 请求头<br>Request Headers:</p>
<ol>
<li>accept encoding: gzip,deflate,支持的压缩方式</li>
<li>connection: keep-alive</li>
<li>cookie:把本地的cookie传给服务器</li>
<li>referer: 来源（可以检查是不是跨域了，检查是不是爬虫（来路不正））</li>
<li>user agent: 探针，告诉服务器本地的环境是什么，Mozilla/5.0，在爬虫的时候，伪造这个也是很重要的。<br><img src="https://upload-images.jianshu.io/upload_images/7728915-4bd4f510dde2b867.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>前面带有冒号的说明这是http2的一些参数。<br><img src="https://upload-images.jianshu.io/upload_images/7728915-1a15ba6bda6d2254.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="请求.png"></li>
</ol>
</li>
<li><p>HTTP响应组成：状态行、消息报头、响应正文。<br>其中，状态行+消息报头 = 响应头<br>Response Header:</p>
</li>
</ul>
<ol>
<li>content-encoding:与request的accept encoding相对应，内容是压缩的</li>
<li>content-length:响应体的大小，为了让浏览器正确解析内容</li>
<li>tracecode:追踪码（百度）<br><img src="https://upload-images.jianshu.io/upload_images/7728915-0373ebff70618cf4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="响应.png"><br>content-type有个坑，前端没有填的话可能会出错，因为后端用的也是框架，他们也不知道有这个东西。</li>
</ol>
<ul>
<li>请求行组成：以一个方法符号开头（GET,POST,OPTION等），后面跟着请求的URI（资源的真正的路径）和协议的版本（http1.0，http1.1，http2.0）。<br>只要文本后面跟着回车换行符，就标志着一行结束了。</li>
<li>状态行组成：服务器HTTP协议的版本，服务器发回的响应状态代码和状<br>态代码的文本描述</li>
</ul>
<h5 id="HTTP缓存相关"><a href="#HTTP缓存相关" class="headerlink" title="HTTP缓存相关"></a>HTTP缓存相关</h5><p>涉及响应头和请求头中expire,last-modified等参数。<br>详情请见之前的一篇文章。<br><a href="https://www.jianshu.com/p/09fa84040ea6" target="_blank" rel="noopener">https://www.jianshu.com/p/09fa84040ea6</a><br><img src="https://upload-images.jianshu.io/upload_images/7728915-8148550f75de1770.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><img src="https://upload-images.jianshu.io/upload_images/7728915-0e147ab387683b7b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h5 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h5><p>GET（select）： 请求获取Request-URI所标识的资源<br>POST(create)： 在Request-URI所标识的资源后附加新的数据<br>HEAD： 请求获取由Request-URI所标识的资源的响应消息报头 （相当于ping方法来进行测试,只取得响应头而不需要响应体）<br>PUT(update)： 请求服务器存储一个资源，并用Request-URI作为其标识<br>DELETE(delete)： 请求服务器删除Request-URI所标识的资源<br>TRACE： 请求服务器回送收到的请求信息，主要用于测试或诊断<br>CONNECT：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务OPTIONS： 请求查询服务器的性能，或者查询与资源相关的选项和需求</p>
<p>GET，POST，PUT，DELETE代表增删查改的四个操作。</p>
<h5 id="Cookies和Session"><a href="#Cookies和Session" class="headerlink" title="Cookies和Session"></a>Cookies和Session</h5><p>由于HTTP是无状态的的协议，所以需要Session和Cookies来维持状态。<br>会话（Session）跟踪是Web程序中常用的技术，用来跟踪用户的整个会话。<br>在程序中，会话跟踪是很重要的事情。理论上，一个用户的所有请求操作都应该属于同一个会话，而另一个用户的所有请求操作则应该属于另一个会话，二者不能混淆。例如，用户A在超市购买的任何商品都应该放在A的购物车内，不论是用户A什么时间购买的，这都是属于同一个会话的，不能放入用户B或用户C的购物车内，这不属于同一个会话。</p>
<p>而Web应用程序是使用HTTP协议传输数据的。HTTP协议是无状态的协议。一旦数据交换完毕，客户端与服务器端的连接就会关闭，再次交换数据需要建立新的连接。这就意味着服务器无法从连接上跟踪会话。即用户A购买了一件商品放入购物车内，当再次购买商品时服务器已经无法判断该购买行为是属于用户A的会话还是用户B的会话了。要跟踪该会话，必须引入一种机制。</p>
<blockquote>
<p>Cookies是保存在客户端的小段文本，随客户端点每一个请求发送该url<br>下的所有cookies到服务器端。<br>客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务 器。服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容。</p>
</blockquote>
<blockquote>
<p><code>Session</code>则保存在服务器端，通过唯一的值<code>sessionID</code>来区别每一个用户。<br><code>SessionID</code>随每个连接请求发送到服务器，服务器根据<code>sessionID</code>来识别客户端，再通过<code>session</code> 的<code>key</code>获取<code>session值</code>。<br><code>Session</code>是另一种记录客户状态的机制，不同的是<code>Cookie</code>保存在客户端浏览器中，而<code>Session</code>保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是<code>Session</code>。客户端浏览器再次访问时只需要从该<code>Session</code>中查找该客户的状态就可以了。</p>
</blockquote>
<p>如果说Cookie机制是通过检查客户身上的“通行证”来确定客户身份的话，那么Session机制就是通过检查服务器上的“客户明细表”来确认客户身份。Session相当于程序在服务器上建立的一份客户档案，客户来访的时候只需要查询客户档案表就可以了。</p>
<p>而服务器就在Session记录相关的信息（客户端的编号等）</p>
<h6 id="Cookies的使用"><a href="#Cookies的使用" class="headerlink" title="Cookies的使用"></a>Cookies的使用</h6><p><img src="https://upload-images.jianshu.io/upload_images/7728915-038d4ff41d4b4e0b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ol>
<li>Cookie：客户端将服务器设置的Cookie返回到服务器;</li>
<li>Set-Cookie：服务器向客户端设置Cookie;<br>服务器在响应消息中用Set-Cookie头将Cookie的内容回送给客户端，客户端在新的请求中将相同的内容携带在Cookie头中发送给服务器。从而实现会话的保持。<h6 id="Session的使用"><a href="#Session的使用" class="headerlink" title="Session的使用"></a>Session的使用</h6><img src="https://upload-images.jianshu.io/upload_images/7728915-852d985ba5657de2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li>
</ol>
<ul>
<li><p>使用Cookie来实现<br> 简单的说，当你登录一个网站的时候，如果web服务器端使用的是session,那么所有的数据都保存在服务器上面，</p>
<pre><code>客户端每次请求服务器的时候会发送 当前会话的session_id，服务器根据当前session_id判断相应的用户数据标志，以确定用户是否登录，或具有某种权限。
由于数据是存储在服务器 上面，所以你不能伪造，但是如果你能够获取某个登录用户的session_id，用特殊的浏览器伪造该用户的请求也是能够成功的。
session_id是服务 器和客户端链接时候随机分配的，一般来说是不会有重复，但如果有大量的并发请求，也不是没有重复的可能性，我曾经就遇到过一次。
登录某个网站，开始显示的 是自己的信息，等一段时间超时了，一刷新，居然显示了别人的信息。
</code></pre><p>   Session是由应用服务器维持的一个服务器端的存储空间，用户在连接服务器时，会由服务器生成一个唯一的SessionID,用该SessionID 为标识符来存取服务器端的Session存储空间。而SessionID这一数据则是保存到客户端，用Cookie保存的，用户提交页面时，会将这一 SessionID提交到服务器端，来存取Session数据。这一过程，是不用开发人员干预的。所以一旦客户端禁用Cookie，那么Session也会失效</p>
</li>
<li>使用URL回显来实现<br>使用URL附加信息的方式，也就是像我们经常看到JSP网站会有aaa.jsp?JSESSIONID=*一样的。这种方式和第一种方式里面不设置Cookie过期时间是一样的。(URL重写，就是把session id直接附加在URL路径的后面。)</li>
</ul>
<h5 id="HTTPS协议分析"><a href="#HTTPS协议分析" class="headerlink" title="HTTPS协议分析"></a>HTTPS协议分析</h5><p>HTTPS是Hypertext Transfer Protocol over Secure Socket Layer的缩写，即HTTP over SSL，可理解为基于SSL的HTTP协议。HTTPS协议安全是由SSL协议实现的。 </p>
<p><strong>http和https的主要区别：</strong></p>
<ul>
<li><p>HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。</p>
</li>
<li><p>HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。</p>
</li>
<li><p>HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p>
</li>
<li><p>HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。<br>关于密钥公钥可以参考之前的文章：<br><a href="https://www.jianshu.com/p/db9804a74456" target="_blank" rel="noopener">https://www.jianshu.com/p/db9804a74456</a></p>
<h5 id="HTTP2协议栈"><a href="#HTTP2协议栈" class="headerlink" title="HTTP2协议栈"></a>HTTP2协议栈</h5></li>
<li><strong>HTTP2协议的特点</strong>：</li>
<li><strong>使用二进制格式传输，更高效、更紧凑。</strong><br>TTP 2.0 中所有加强性能的核心点在于此。在之前的 HTTP 版本中，我们是通过文本的方式传输数据。在 HTTP 2.0 中引入了新的编码机制，所有传输的数据都会被分割，并采用二进制格式编码。</li>
<li><p><strong>对报头压缩，降低开销。</strong><br>在 HTTP 1.X 中，我们使用文本的形式传输 header，在 header 携带 cookie 的情况下，可能每次都需要重复传输几百到几千的字节。</p>
<p>在 HTTP 2.0 中，使用了 HPACK 压缩格式对传输的 header 进行编码，减少了 header 的大小。并在两端维护了索引表，用于记录出现过的 header ，后面在传输过程中就可以传输已经记录过的 header 的键名，对端收到数据后就可以通过键名找到对应的值。</p>
</li>
<li><p><strong>多路复用，一个网络连接实现并行请求。</strong><br>在 HTTP 2.0 中，有两个非常重要的概念，分别是帧（frame）和流（stream）。</p>
<p>帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。</p>
<p>多路复用，就是在一个 TCP 连接中可以存在多条流。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。</p>
</li>
<li><p><strong>服务器主动推送，减少请求的延迟 。</strong><br>在 HTTP 2.0 中，服务端可以在客户端某个请求后，主动推送其他资源。</p>
<p>可以想象以下情况，某些资源客户端是一定会请求的，这时就可以采取服务端 push 的技术，提前给客户端推送必要的资源，这样就可以相对减少一点延迟时间。当然在浏览器兼容的情况下你也可以使用 prefetch 。</p>
</li>
<li><strong>默认使用加密。</strong><h5 id="了解HTTP-3-QUIC"><a href="#了解HTTP-3-QUIC" class="headerlink" title="了解HTTP 3/QUIC"></a>了解HTTP 3/QUIC</h5>HTTP-over-QUIC被更名为HTTP 3<br>HTTP 3与HTTP 1.1和HTTP 2没有直接的关系</li>
<li>该协议支持多路复用，虽然 HTTP 2.0 也支持多路复用，但是下层仍是 TCP，因为 TCP 的重传机制，只要一个包丢失就得判断丢失包并且重传，导致发生队头阻塞的问题，但是 UDP 没有这个机制</li>
<li>实现了自己的加密协议，通过类似 TCP 的 TFO 机制可以实现 0-RTT，当然 TLS 1.3 已经实现了 0-RTT 了</li>
<li>支持重传和纠错机制（向前恢复），在只丢失一个包的情况下不需要重传，使用纠错机制恢复丢失的包<ul>
<li>纠错机制：通过异或的方式，算出发出去的数据的异或值并单独发出一个包，服务端在发现有一个包丢失的情况下，通过其他数据包和异或值包算出丢失包</li>
<li>在丢失两个包或以上的情况就使用重传机制，因为算不出来了</li>
</ul>
</li>
</ul>
<h5 id="HTTP与反向代理"><a href="#HTTP与反向代理" class="headerlink" title="HTTP与反向代理"></a>HTTP与反向代理</h5><h6 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h6><p>正向代理 是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端必须要进行一些特别的设置才能使用正向代理。<br>用途：<br>（1）访问原来无法访问的资源，如google<br>（2） 可以做缓存，加速访问资源(服务器缓存要谨慎)<br>（3）对客户端访问授权，上网进行认证<br>（4）代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息<br><img src="https://upload-images.jianshu.io/upload_images/7728915-73a1c99a31b80f63.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="正向代理.png"></p>
<h6 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h6><p>反向代理的用途：</p>
<ul>
<li>加密和SSL加速 </li>
<li>负载均衡 </li>
<li>缓存静态内容 </li>
<li>压缩 </li>
<li>减速上传 （百度网盘上传下载文件）</li>
<li>安全 （黑客要先攻击代理服务器这第一道防线才能继续攻击我们内网的服务器拿到数据库口令）</li>
<li>外网发布</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/7728915-48ac98e3a2cec254.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>参考博文：<a href="https://yuchengkai.cn/docs/cs/#%E7%8A%B6%E6%80%81%E6%9C%BA" target="_blank" rel="noopener">https://yuchengkai.cn/docs/cs/#%E7%8A%B6%E6%80%81%E6%9C%BA</a></p>
<h4 id="Nginx安装及配置"><a href="#Nginx安装及配置" class="headerlink" title="Nginx安装及配置"></a>Nginx安装及配置</h4><ul>
<li>环境：linux服务器，CentOS系统<br><a href="http://www.runoob.com/linux/nginx-install-setup.html" target="_blank" rel="noopener">http://www.runoob.com/linux/nginx-install-setup.html</a><br><img src="https://upload-images.jianshu.io/upload_images/7728915-dc7b088e95334311.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li>
</ul>
<p>Nginx 配置时使用vi出现了一些问题，i 在光标前插入字符，要修改内容就要先输入i才能进行下一步操作。修改完成之后点击esc然后:wq就可以保存并退出了。</p>
<p>检查配置文件nginx.conf的正确性命令：<br>也成功了。<br><img src="https://upload-images.jianshu.io/upload_images/7728915-3d2f5037d0d0f08b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>注意路径，注意安装版本。<br><img src="https://upload-images.jianshu.io/upload_images/7728915-29ec6065e5a123f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>遇到了一个困扰很久的问题：<br><a href="https://www.cnblogs.com/toosuo/p/3571114.html" target="_blank" rel="noopener">Nginx [emerg]: bind() to 0.0.0.0:80 failed (98: Address already in use)</a><br><img src="https://upload-images.jianshu.io/upload_images/7728915-04e5595de54807a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><img src="https://upload-images.jianshu.io/upload_images/7728915-7bfa96cdabda557c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>使用netstat -ltunp去看端口的使用情况。<br>发现是tcp在占用这个端口，直接使用命令关闭。</p>
<pre><code>sudo fuser -k 80/tcp
</code></pre><h5 id="nginx-conf配置"><a href="#nginx-conf配置" class="headerlink" title="nginx.conf配置"></a>nginx.conf配置</h5><p>将每一项的配置都进行注释，便于理解。<br><img src="https://upload-images.jianshu.io/upload_images/7728915-56f90f71bbdded63.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br><img src="https://upload-images.jianshu.io/upload_images/7728915-443714b3be06c055.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br><img src="https://upload-images.jianshu.io/upload_images/7728915-7adf2496f4c5332a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<h5 id="怎么配反向代理"><a href="#怎么配反向代理" class="headerlink" title="怎么配反向代理"></a>怎么配反向代理</h5><p>在sever前面加上<br><img src="https://upload-images.jianshu.io/upload_images/7728915-6981b13711f0e595.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>上图的意思就是反向代理到本机上面的8080端口。如果多加几个ip就能做负载均衡。<br>接下来进行设置：<br>location+反向代理的路径（这是用户输入的路径）<br>proxy_pass:后面一定要跟协议头（http://）proxy_pass后面的路径是真正要去的服务器。<br>注意：配置的时候一定要原封不动的将下面的这些都复制一波。<br>更加详细的可以看资料中文件。<br><img src="https://upload-images.jianshu.io/upload_images/7728915-6bef88c3d6da585a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>然后就ok了，完结撒花。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/09/HTTP协议那些事-0/" data-id="ck35ybx6g000bnrh262skv443" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JS语言精粹" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/08/JS语言精粹/" class="article-date">
  <time datetime="2019-06-08T09:00:21.000Z" itemprop="datePublished">2019-06-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/京城一灯第一章/">京城一灯第一章</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/08/JS语言精粹/">JS语言精粹</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>小小知识点：</p>
<ol>
<li><p>typeof是一个操作符，并不是function。所以typeof后面不用加括号。<br>参见MDN<br><img src="https://upload-images.jianshu.io/upload_images/7728915-d084d87d10f0f7f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
</li>
<li><p>关于           typeof null // Object<br>null 值表示一个空对象指针，而这也正是使用 typeof 操作符检测 null 值时会返回”object”的原因，如</p>
</li>
<li><p>只声明不赋值，则默认值为undefined</p>
</li>
<li><p>关于const</p>
<pre><code>const num = 1;
num = 2; //Uncaught TypeError: Assignment to constant variable.

const obj = {
  data: 1
}
obj.data = 2;//没有报错
</code></pre><p> 咦，不是说const定义的常量不能被改变吗？<br>const仅保证指针不发生改变，<strong>修改对象的属性不会改变对象的指针，除非我们直接重写对象</strong>也就是说const定义的引用类型只要指针不发生改变，其他的不论如何改变都是允许的。所以</p>
<pre><code>const obj = {
    data:1
}

obj = {
    data:4
}//Uncaught TypeError: Assignment to constant variable.
</code></pre></li>
<li><p>关于arguments，我们更推荐这么使用<br>这时的args就是真正的数组了。</p>
<pre><code>function foo(...args){
    return args;
}
foo(1,2,3)//[1,2,3]
</code></pre></li>
<li>函数的返回值有两种结果：<br>显示调用return 返回 return 后表达式的求值<br>没有调用return 返回 undefined</li>
<li>关于this<br>在普通函数中<br>严格模式下，this指向undefined<br>非严格模式下，this指向全局对象（Node中的global，浏览器中的window）<br>在ES6中默认使用严格模式，所以在普通函数中你会发现this指向undefined。</li>
<li>语句和表达式<br><strong>JavaScript是一种语句优先的语言</strong><br>逗号运算符的左右两侧都必须是表达式！如果是a:1，那肯定会报错。<blockquote>
<p>逗号表达式的一般形式是：表达式1，表达式2，表达式3……表达式n<br>逗号表达式的求解过程是：先计算表达式1的值，再计算表达式2的值，……一直计算到表达式n的值。最后整个逗号表达式的值是表达式n的值。<br>看下面几个例子：<br>x=8*2,x*4 /<em>整个表达式的值为64，x的值为16</em>/<br>(x=8*2,x*4),x<em>2 /</em>整个表达式的值为128，x的值为16<em>/<br>x=(z=5,5\</em>2) /<em>整个表达式为赋值表达式，它的值为10，z的值为5</em>/<br>x=z=5,5*2 /<em>整个表达式为逗号表达式，它的值为10，x和z的值都为5</em>/<br>逗号表达式用的地方不太多，一般情况是在给循环变量赋初值时才用得到。所以程序中并不是所有的逗号都要看成逗号运算符，尤其是在函数调用时，各个参数是用逗号隔开的，这时逗号就不是逗号运算符。 </p>
</blockquote>
</li>
</ol>
<p>有时候会遇到一些很奇怪的错误，就尽量往语句优先这个方向想。</p>
<ol start="9">
<li><p>立即执行函数</p>
<p>   function(){}() //Uncaught SyntaxError: Unexpected token (<br>   这里为什么会报错呢？如果不加第一对括号，无论是</p>
<pre><code>function(){
   /* 代码 */
}();
</code></pre><p> 还是</p>
<pre><code>function(){
    /* 代码 */
}
</code></pre><p> 都是会报错的。因为js的引擎会把这里的 function 看成是函数声明，而函数声明不允许没有函数名，因此会对匿名函数报错。</p>
<p>   匿名函数只允许以表达式的形式存在，例如：</p>
<pre><code>setTimeout(function(){
    /* 代码 */
}, 1000);
</code></pre><p> 这里的匿名函数就是作为 setTimeout 的一个参数，是表达式，这种写法是允许的。</p>
<p> 或者：</p>
<pre><code>var foo = function(){
    /* 代码 */
};
</code></pre><p>   也就是说我们稍微修改一下，var fn = function(){}()，也不会报错。<br>   这是为什么？<br>   因为这是把一个匿名函数赋值给一个变量，匿名函数在该语句中充当函数表达式的角色。</p>
<p> 如果这里的函数有名字呢？不会报错，但语义会发生变化。例如：</p>
<pre><code>function foo(x){
    /* 代码 */
}(1);
</code></pre><p> 其实这里的代码就相当于</p>
<pre><code>function foo(x){
    /* 代码 */
};
(1);
</code></pre><p> 原因是js引擎会认为前面的函数是一个函数声明的语句，而后面的(1)是另一个单独的语句，于是执行后面的语句，在控制台输出1。</p>
<p> js的括号有几种不同的作用，其中一种作用就是：表示在括号内的是表达式而不是语句。具体到这个例子上，第一对括号就是告诉js引擎，这里面的匿名函数是一个函数表达式，而不是函数声明语句。因此加了这个括号之后，就不会报错了。<br>   (function(){})() //强制其理解为函数，()里面放表达式，“函数()”表示执行该函数，即声明后立即执行了。</p>
</li>
<li><p>补充原型链的一个小知识：<br>每个原型对象prototype中都有一个constructor属性，默认指向函数本身。</p>
</li>
<li><p>闭包和内存泄露的问题<br>首先应当明确的是内存泄漏可能是代码的问题，而不是闭包的问题，如果为了避免内存泄漏而不去用闭包的话，有些问题是很难解决的。</p>
</li>
</ol>
<p>在IE9之前，BOM和DOM对象都是使用C++以COM对象的形式来实现的，COM对象的垃圾收集机制采用的就是计数策略，所以IE中只要涉及到BOM和DOM对象，就很可能会存在循环引用的问题。</p>
<p>闭包实际上很容易造成JavaScript对象和DOM对象的隐蔽循环引用。也就是说，只要闭包的作用域链中保存着一个HTML元素，那么就意味着这个元素将无法被销毁。例如下面的：</p>
<pre><code>  function assignHandler(){
    var element = document.getElementById(&quot;someElement&quot;);
    element.onclick = function(){
        alert (element.id);
   }; 
}
</code></pre><p>注意，闭包的概念是一个函数的返回值是另外一个函数，返回的那个函数如果调用了其父函数内部的其他值，这是一个element元素事件处理的一个闭包。这个闭包创建了一个循环引用。</p>
<ol>
<li>JavaScript对象element引用了一个DOM对象（其id为“someElement”）； JS(element) —-&gt; DOM(someElemet)</li>
<li>该DOM对象的onclick属性引用了匿名函数闭包，而闭包可以引用外部函数assignHandler 的整个活动对象，包括element ； DOM(someElement.onclick) —-&gt;JS(element)<br>匿名函数一直保存着对assginHandler()活动对象的引用，它所占的内存永远不会被回收。</li>
</ol>
<p>可以对代码稍稍改进：</p>
<pre><code>  function assignHandler(){
    var element = document.getElementById(&quot;someElement&quot;);
    var id = element.id;
    element.onclick = function(){
        alert (id);
   }; 
   element = null;
}
</code></pre><p>可以首先通过引用一个副本变量消除循环引用，但是这个闭包包含外部函数的全部活动对象，所以就算不直接引用，匿名函数一直都包含着对element的引用。所以最后需要手动设置element变量为null.</p>
<p><strong>闭包的很大作用是可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。<br>只要变量被任何一个闭包使用了，就会被添到词法环境中，被该作用域下所有闭包共享。</strong></p>
<p>绝对不能因为内存泄漏而不使用闭包。</p>
<p>JS中只要越过了闭包，作用域，原型这几座大山，对JS的理解就高了一个层次了！<br>作用域的文章可以查看下面的网址！！！<a href="https://lemontency.github.io/2019/03/20/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/" target="_blank" rel="noopener">https://lemontency.github.io/2019/03/20/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/</a></p>
<p>最后来几道作用域和this的题吧！</p>
<pre><code>if(!(username in window)){
    var username = &apos;zty&apos;;
}
console.log(username) //undefined
</code></pre><p>怎么理解呢。首先在ES5的代码中并没有块级作用域的概念，var username直接变量提升到最顶部，此时全局作用域中有username并且值为undefined，所以!(username in window)为false，跳过赋值部分，username依旧是undefined。</p>
<pre><code>//差点就错了
//执行顺序是
//声明函数foo，注意是整个函数一起提升上去的
//调用函数foo
//声明变量test
//console.log(test)
//test = &quot;bbb&quot;
//console.log(test)
var test = &quot;aaa&quot;;
function foo(){
    console.log(test);
    var test = &quot;bbb&quot;;
    console.log(test);
}
foo(); //undefined bbb 
console.log(test)//aaa
</code></pre><p>也就是说上面的代码的执行顺序其实是这样的：</p>
<pre><code>var test = aaa;
function foo(){
    var test;
    console.log(test);
    var test = &quot;bbb&quot;;
    console.log(test);
}
foo();
console.log(test);

var name = &apos;global&apos;;
function A(name){
    //传参的优先级要高于后面的声明
    //虽然后面有变量提升，但是是没有影响的
    alert(name);//3
    this.name = name;
    var name = &apos;1&apos;;
}
A.prototype.name = &apos;2&apos;;
var a = new A(&apos;3&apos;);
alert(a.name);//3
delete a.name;//删除对象的属性但是不删除对象原型链上的属性
alert(a.name);//2
</code></pre><p>比较好的实践就是把要用到的变量声明都写到函数最前面。<br>再来看一道容易做的题：</p>
<pre><code>function fun(n,o){
    console.log(o);
    return {
        fun:function(m){
            return fun(m,n)
        }
    }
}
var a = fun(0);//undefined
a.fun(1);
a.fun(2);
var b = fun(0).fun(1).fun(2).fun(3);
var c = fun(0).fun(1);
c.fun(2);c.fun(3);
</code></pre><p>我们看到：return返回的对象的fun属性对应一个新建的函数对象，这个函数对象将形成一个闭包作用域，使其能够访问外层函数的变量n及外层函数fun,为了不让fun属性和fun对象混淆，先更改一下代码：</p>
<pre><code>function _fun_(n,o){
    console.log(o);
    return {
        fun:function(m){
            return _fun_(m,n)
        }
    }
}
var a = _fun_(0);//undefined
a.fun(1);//
a.fun(2);
var b = _fun_(0).fun(1).fun(2).fun(3);
var c = _fun_(0).fun(1);
c.fun(2);c.fun(3);
</code></pre><p>这道题难度挺大，但是一定要做。<br>讲师小tips：每次调用fun就相对应的在纸上还原作用域链。</p>
<p>_fun_函数执行,因为第2个参数未定义，输出undefined。然后返回一个对象，带有fun属性，指向一个函数对象，带有闭包,能够访问到_fun_和变量n。<br>a.fun(1)执行返回的对象的fun方法，传入m的值1，调用返回_fun_(1,0)，打印出0；<br>a.fun(1)执行返回的对象的fun方法，传入m的值1，调用返回_fun_(2,0)，打印出0；</p>
<p>接下来的var b = _fun_(0).fun(1).fun(2).fun(3);可以等价为</p>
<p>var b = _fun_(0);<br>var b1 = b.fun(1);<br>var b2 = b1.fun(2);<br>var b3 = b2.fun(3);<br>前两句的和我们刚刚分析的情况是一样的，var b = _fun_(0);首先返回一个对象，带有fun属性，指向一个函数对象，带有闭包，能够访问_fun_和变量n。<br>b.fun(1)传入m的值为1，调用返回_fun_(1,0)，打印出0；<br>b1.fun(2)传入m的值为2，调用返回_fun_(2,1)，打印出1；<br>b2.fun(3)传入m的值为3，调用返回_fun_(3,2)，打印出2；</p>
<p>接下来var c = _fun_(0).fun(1);情况和前面的是一样的，先打印出undefined，再打印出0;<br>c.fun(2)传入m的值为2，调用返回_fun_(2,1)，打印出1；<br>c.fun(3)传入m的值为，调用返回_fun_(3,1)，打印出1；</p>
<p>还要注意，这里传递的是一个简单的数据类型，而不是引用的数据类型。<br>看看这个？<br><a href="https://lemontency.github.io/2019/03/20/JS%E4%B8%AD%E7%9A%84%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E6%8C%89%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98-1/" target="_blank" rel="noopener">https://lemontency.github.io/2019/03/20/JS%E4%B8%AD%E7%9A%84%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E6%8C%89%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98-1/</a></p>
<p>参考：<a href="https://www.zhihu.com/question/48238548" target="_blank" rel="noopener">https://www.zhihu.com/question/48238548</a><br><a href="https://segmentfault.com/a/1190000004187681" target="_blank" rel="noopener">https://segmentfault.com/a/1190000004187681</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/08/JS语言精粹/" data-id="ck35ybx6j000fnrh2ya6v88dj" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Arguments对象" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/29/Arguments对象/" class="article-date">
  <time datetime="2019-03-29T07:38:57.000Z" itemprop="datePublished">2019-03-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JS基础/">JS基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/29/Arguments对象/">Arguments对象</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p><code>arguments</code> 是一个对应于传递给函数的参数的类数组对象。<br>是<code>非箭头函数</code>中都可以用的<code>局部变量</code>。可以使用arguments对象在函数中引用函数的参数。如果一个函数传递了三个参数，可以用如下方式引用：</p>
<pre><code>argument[0]
argument[1]
argument[2]
</code></pre><p>当然，参数也可以被设置：</p>
<pre><code>argument[2] = &apos;new value&apos;
</code></pre><p><strong>需要注意的是，arguments并不是一个数组，只是一个类数组</strong><br>类似于数组，但是只有length和索引的性质，要将他转为数组可以用以下方法：</p>
<pre><code>var args = Array.prototype.slice.call(arguments);
var args = [].slice.call(arguments);

// ES2015
const args = Array.from(arguments);
const args = [...arguments];
</code></pre><p>看看具体应用：</p>
<pre><code>function test(){
    console.log(arguments)
}
test(1,2,3,4,5,6)//Arguments { 0: 1, 1: 2, 2: 3, 3: 4, 4: 5, 5: 6}


function test(){
    console.log(arguments);
    var args = [].slice.call(arguments)
    console.log(args)
}
test(1,2,3,4,5,6)//{ 0: 1, 1: 2, 2: 3, 3: 4, 4: 5, 5: 6}
    //[ 1, 2, 3, 4, 5 ]
</code></pre><h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><h4 id="遍历参数求和"><a href="#遍历参数求和" class="headerlink" title="遍历参数求和"></a>遍历参数求和</h4><pre><code>function add(){
    var sum = 0,
        len = arguments.length;
    for(var i = 0; i &lt; len; i++){
        sum+ = arguments[i];
    }
    return sum;
}
</code></pre><h4 id="定义连接字符串的函数"><a href="#定义连接字符串的函数" class="headerlink" title="定义连接字符串的函数"></a>定义连接字符串的函数</h4><pre><code>function myConcat(separator){
    var args = Array.prototype.slice.call(arguments,1);
    return args.join(separator)
}

myConcat(&apos;;&apos;,2,4,5,7)//&quot;2;4;5;7&quot;
</code></pre><h4 id="默认参数，剩余参数，解构赋值参数"><a href="#默认参数，剩余参数，解构赋值参数" class="headerlink" title="默认参数，剩余参数，解构赋值参数"></a>默认参数，剩余参数，解构赋值参数</h4><pre><code>function foo(...args){
    return args;
}
foo(1,2,3)//[1,2,3]
</code></pre><p><strong>在严格模式下，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Rest_parameters" target="_blank" rel="noopener">剩余参数</a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Default_parameters" target="_blank" rel="noopener">默认参数</a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" target="_blank" rel="noopener">解构赋值</a>参数的存在不会改变 <code>arguments</code>对象的行为，但是在非严格模式下就有所不同了。</strong></p>
<pre><code>function foo(n){
    arguments[0] = 90;
    console.log(n);
}
foo(10);//99
</code></pre><p><strong>当非严格模式中的函数</strong>有<strong>包含<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Rest_parameters" target="_blank" rel="noopener">剩余参数</a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Default_parameters" target="_blank" rel="noopener">默认参数</a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" target="_blank" rel="noopener">解构赋值</a>，那么<code>arguments</code>对象中的值</strong>不会<strong>跟踪参数的值（反之亦然）。相反, <code>arguments</code>反映了调用时提供的参数：</strong></p>
<pre><code>function foo(n=55){
    arguments[0] = 99;
    console.log(n);//55
}
foo()
</code></pre><p>你看，这里的n还是55，因为函数中包括了默认参数的这个情况了。并且你看，默认参数</p>
<pre><code>function foo(n=56){
    console.log(arguments[0]);
}
foo()//undefined
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/29/Arguments对象/" data-id="ck35ybx6c0008nrh2sq4goudq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-前端学习资源-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/23/前端学习资源-1/" class="article-date">
  <time datetime="2019-03-23T09:44:52.000Z" itemprop="datePublished">2019-03-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JS资源/">JS资源</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/23/前端学习资源-1/">前端学习资源</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="fe-material"><a href="#fe-material" class="headerlink" title="fe-material"></a>fe-material</h2><p>整理最有趣的前端技术教程及文档，欢迎大家都来补充让更多的多学找到学习一手好资料</p>
<h3 id="前端工具"><a href="#前端工具" class="headerlink" title="前端工具"></a>前端工具</h3><ul>
<li><p>Git</p>
<ol>
<li><a href="https://backlog.com/git-tutorial/cn/intro/intro1_1.html" target="_blank" rel="noopener">入门篇</a></li>
<li><a href="https://backlog.com/git-tutorial/cn/stepup/stepup1_1.html" target="_blank" rel="noopener">高级篇</a></li>
<li><a href="https://backlog.com/git-tutorial/cn/reference/" target="_blank" rel="noopener">索引篇</a></li>
<li><a href="https://www.atlassian.com/git/tutorials/merging-vs-rebasing" target="_blank" rel="noopener">原版</a></li>
<li><a href="https://github.com/geeeeeeeeek/git-recipes/wiki/1.1-%E6%9E%9C%E5%A3%B3%E4%B8%AD%E7%9A%84-Git" target="_blank" rel="noopener">原版翻译</a></li>
</ol>
</li>
<li><p>Webpack</p>
<ol>
<li><a href="https://doc.webpack-china.org/concepts/" target="_blank" rel="noopener">文档</a></li>
<li><a href="https://doc.webpack-china.org/plugins/" target="_blank" rel="noopener">插件</a></li>
</ol>
</li>
<li><p>Paracle</p>
<ol>
<li><a href="https://parceljs.org/" target="_blank" rel="noopener">文档</a></li>
</ol>
</li>
<li><p>Gulp</p>
<ol>
<li><a href="https://www.gulpjs.com.cn/" target="_blank" rel="noopener">文档</a></li>
</ol>
</li>
<li><p>Grunt</p>
<ol>
<li><a href="http://www.gruntjs.net/" target="_blank" rel="noopener">文档</a></li>
</ol>
</li>
<li><p>Rollup</p>
<ol>
<li><a href="http://www.rollupjs.com/" target="_blank" rel="noopener">文档</a></li>
</ol>
</li>
<li><p>Browserify</p>
<ol>
<li><a href="http://browserify.org/" target="_blank" rel="noopener">官方文档</a></li>
</ol>
</li>
<li><p>Lerna</p>
<ol>
<li><a href="https://github.com/lerna/lerna" target="_blank" rel="noopener">官方文档</a></li>
<li><a href="https://www.jianshu.com/p/63ec67445b0f" target="_blank" rel="noopener">入门介绍</a></li>
</ol>
</li>
<li><p>Eslint</p>
<ol>
<li><a href="https://mysticatea.github.io/vue-eslint-demo/" target="_blank" rel="noopener">vue eslint</a><h3 id="前端框架"><a href="#前端框架" class="headerlink" title="前端框架"></a>前端框架</h3></li>
</ol>
</li>
<li><p>Vue</p>
<ol>
<li><a href="https://cn.vuejs.org/" target="_blank" rel="noopener">基本教程</a></li>
<li><a href="https://router.vuejs.org/" target="_blank" rel="noopener">路由</a></li>
<li><a href="https://vuex.vuejs.org/" target="_blank" rel="noopener">Vuex</a></li>
<li><a href="https://ssr.vuejs.org/" target="_blank" rel="noopener">SSR</a></li>
</ol>
</li>
<li><p>React</p>
<ol>
<li><a href="https://doc.react-china.org/" target="_blank" rel="noopener">文档</a></li>
<li><a href="http://cn.redux.js.org/" target="_blank" rel="noopener">Redux官方文档</a></li>
<li><a href="http://www.redux.org.cn/" target="_blank" rel="noopener">Redux中文社区</a></li>
<li><a href="https://zeit.co/blog/next4" target="_blank" rel="noopener">Next.js</a></li>
<li><a href="http://react-china.org/t/next-js/12525" target="_blank" rel="noopener">Next.js中文文档</a></li>
<li><a href="https://juejin.im/entry/59791d8f6fb9a03c391b557e" target="_blank" rel="noopener">Next.js掘金博客</a></li>
</ol>
</li>
<li><p>Angular</p>
<ol>
<li><a href="https://angular.cn/" target="_blank" rel="noopener">官方文档</a></li>
</ol>
</li>
<li><p>Riot</p>
<ol>
<li><a href="http://riotjs.com/v2/zh/" target="_blank" rel="noopener">文档</a></li>
</ol>
</li>
<li><p>Koa</p>
<blockquote>
<p>Express升级后的框架，抽象设计更彻底，强大、自由、灵活</p>
</blockquote>
<ol>
<li><a href="https://koa.bootcss.com/" target="_blank" rel="noopener">文档</a></li>
</ol>
</li>
<li><p>Express</p>
<blockquote>
<p> Node.js开发最容易上手的业务应用开发框架</p>
</blockquote>
<ol>
<li><a href="http://expressjs.com/zh-cn/" target="_blank" rel="noopener">文档</a></li>
</ol>
</li>
<li><p>MobX</p>
<blockquote>
<p>简单、可扩展的状态管理</p>
<ol>
<li><a href="http://cn.mobx.js.org/" target="_blank" rel="noopener">教程</a></li>
</ol>
</blockquote>
</li>
<li><p>RxJS</p>
<blockquote>
<p>函数式编程最经典的框架</p>
<ol>
<li><a href="http://cn.rx.js.org/" target="_blank" rel="noopener">中文文档</a></li>
</ol>
</blockquote>
</li>
<li><p>Three.js</p>
<blockquote>
<p>3D和游戏必用的JS库</p>
<ol>
<li><a href="https://threejs.org/" target="_blank" rel="noopener">官方网站</a></li>
<li><a href="http://www.hewebgl.com/article/articledir/1" target="_blank" rel="noopener">基础入门-中文网</a></li>
<li><a href="https://teakki.com/p/58a3ef1bf0d40775548c908f" target="_blank" rel="noopener">中文文档+示例</a></li>
</ol>
</blockquote>
</li>
<li><p>d3.js</p>
<blockquote>
<p>数据图表中最强的类库</p>
<ol>
<li><a href="https://d3js.org/" target="_blank" rel="noopener">官方网站</a></li>
<li><a href="https://github.com/xswei/d3js_doc" target="_blank" rel="noopener">中文文档</a></li>
</ol>
</blockquote>
</li>
<li><p>HTML5 动画库</p>
<blockquote>
<p>标准动画库和SVG动画库</p>
<ol>
<li><a href="http://dmitrybaranovskiy.github.io/raphael/" target="_blank" rel="noopener">Raphael</a></li>
<li><a href="http://lmgonzalves.github.io/segment/" target="_blank" rel="noopener">segment</a></li>
<li><a href="https://greensock.com/gsap" target="_blank" rel="noopener">GSAP</a></li>
<li><a href="http://animejs.com/" target="_blank" rel="noopener">anime</a></li>
<li><a href="https://icomoon.io" target="_blank" rel="noopener">免费 SVG 图标</a></li>
</ol>
</blockquote>
</li>
<li><p>视频播放器</p>
<blockquote>
<p>好用的视频播放器</p>
<ol>
<li><a href="https://github.com/bytedance/xgplayer" target="_blank" rel="noopener">xgplayer</a></li>
<li><a href="https://github.com/videojs/video.js" target="_blank" rel="noopener">video.js</a></li>
<li><a href="https://github.com/mediaelement/mediaelement" target="_blank" rel="noopener">mediaelement</a></li>
</ol>
</blockquote>
</li>
</ul>
<h3 id="CSS教程"><a href="#CSS教程" class="headerlink" title="CSS教程"></a>CSS教程</h3><ul>
<li><p>Less</p>
<ol>
<li><a href="http://less.bootcss.com/" target="_blank" rel="noopener">文档</a></li>
</ol>
</li>
<li><p>Sass</p>
<ol>
<li><a href="http://sass.bootcss.com/docs/sass-reference/" target="_blank" rel="noopener">文档</a></li>
</ol>
</li>
<li><p>CSS3布局</p>
<ol>
<li><a href="http://zh.learnlayout.com/" target="_blank" rel="noopener">学习布局</a></li>
</ol>
</li>
</ul>
<h3 id="JavaScript教程"><a href="#JavaScript教程" class="headerlink" title="JavaScript教程"></a>JavaScript教程</h3><ul>
<li><p>ES6</p>
<ol>
<li><a href="http://es6-features.org/#Constants" target="_blank" rel="noopener">权威教程:ECMAScript 6</a></li>
<li><a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">入门教程</a></li>
</ol>
</li>
<li><p>Node</p>
<ol>
<li><a href="http://nodejs.cn/" target="_blank" rel="noopener">官方网站</a></li>
<li><a href="http://nodejs.cn/api/" target="_blank" rel="noopener">官方教程</a></li>
</ol>
</li>
<li><p>ES3</p>
<ol>
<li><a href="http://www.runoob.com/js/js-tutorial.html" target="_blank" rel="noopener">入门教程</a></li>
</ol>
</li>
<li><p>ES5</p>
<ol>
<li><a href="http://www.hahack.com/wiki/javascript-es5.html#es5-%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7" target="_blank" rel="noopener">ES5新特性与ES3的对比</a></li>
<li><a href="http://pij.robinqu.me/JavaScript_Core/ECMAScript/es5.html" target="_blank" rel="noopener">ES5新特性博客</a></li>
</ol>
</li>
</ul>
<h3 id="服务端教程"><a href="#服务端教程" class="headerlink" title="服务端教程"></a>服务端教程</h3><ul>
<li><a href="http://cnt1992.xyz/2016/03/18/simple-intro-to-nginx/" target="_blank" rel="noopener">Nginx入门</a></li>
<li><a href="http://tengine.taobao.org/book/#" target="_blank" rel="noopener">Nginx入门与精通（高级）</a></li>
</ul>
<h3 id="好玩的网站"><a href="#好玩的网站" class="headerlink" title="好玩的网站"></a>好玩的网站</h3><ul>
<li><a href="https://leetcode.com/" target="_blank" rel="noopener">刷题的酷站：leetcode</a></li>
<li><a href="http://microjs.com/" target="_blank" rel="noopener">各种精美的微型前端库</a></li>
<li><a href="https://c7sky.com/syntax-highlighting-with-prismjs.html" target="_blank" rel="noopener">代码高亮</a></li>
</ul>
<h3 id="开源图标"><a href="#开源图标" class="headerlink" title="开源图标"></a>开源图标</h3><ul>
<li><a href="https://nodei.co/" target="_blank" rel="noopener">NPM 图标</a></li>
<li><a href="https://shields.io/" target="_blank" rel="noopener">小图标</a></li>
</ul>
<h3 id="视频技术"><a href="#视频技术" class="headerlink" title="视频技术"></a>视频技术</h3><ul>
<li><a href="https://blog.csdn.net/g332065255/article/details/71158863" target="_blank" rel="noopener"> flv 转 fmp4 </a></li>
<li><a href="https://www.w3.org/TR/media-source/" target="_blank" rel="noopener"> MSE </a></li>
</ul>
<h3 id="动画技术"><a href="#动画技术" class="headerlink" title="动画技术"></a>动画技术</h3><ul>
<li><a href="http://airbnb.io/lottie/" target="_blank" rel="noopener">lottie</a></li>
<li><a href="http://www.html-js.com/article/1628" target="_blank" rel="noopener">贝塞尔曲线扫盲</a></li>
<li><a href="https://gka.js.org/#/?id=%E5%AE%89%E8%A3%85" target="_blank" rel="noopener">帧补偿工具</a></li>
<li><a href="http://dynamicsjs.com/" target="_blank" rel="noopener">简单的动画库</a></li>
</ul>
<h3 id="游戏方向"><a href="#游戏方向" class="headerlink" title="游戏方向"></a>游戏方向</h3><ul>
<li><a href="https://docs.blender.org/manual/zh-hans/dev/getting_started/index.html" target="_blank" rel="noopener">3D 编辑器</a></li>
<li><a href="http://www.cocos.com/docs/native/" target="_blank" rel="noopener">cocos2d引擎</a></li>
<li><a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a></li>
<li><a href="https://unity3d.com/cn" target="_blank" rel="noopener">unity3d</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/23/前端学习资源-1/" data-id="ck35ybx6k000gnrh28mane1u1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-原型与原型链" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/20/原型与原型链/" class="article-date">
  <time datetime="2019-03-20T08:32:53.000Z" itemprop="datePublished">2019-03-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JS基础/">JS基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/20/原型与原型链/">原型与原型链</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="我们在谈论原型链时，究竟在谈些什么？"><a href="#我们在谈论原型链时，究竟在谈些什么？" class="headerlink" title="我们在谈论原型链时，究竟在谈些什么？"></a>我们在谈论原型链时，究竟在谈些什么？</h4><p><img src="https://upload-images.jianshu.io/upload_images/7728915-6f47ab5fc0552353.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>看到上面的图就眼花缭乱？那就对了！接下来我们的目的就是弄懂上面的这张神图！跟着我一起看看吧。</p>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>在谈论继承之前，我们必须先明白以下知识点：</p>
<p> 所有对象都具有__proto__属性，所有函数都具有prototype属性，Fn是一个函数（具有prototype属性），fn对象是从Fn函数new出来的，那么fn函数可以调用Fn.prototype中的所有属性。</p>
<p>也就是说，我们在访问一个对象的属性时，会先在基本属性中查找，如果没有，我们就会沿着它的__proto___属性这条链往上面找，也就是它的构造函数的prototype这条链往上找，这条链条也就是我们所说的原型链。</p>
<p>JS中的继承就是通过原型链来实现的。当我们新建一个对象，这个对象也拥有他的构造函数的prototype上所有的属性和方法。</p>
<h4 id="对象和它的构造函数的关系"><a href="#对象和它的构造函数的关系" class="headerlink" title="对象和它的构造函数的关系"></a>对象和它的构造函数的关系</h4><pre><code> var a = { } //一般推荐这么写

var a = new Object( )  //等于上式

var b = [ ] //一般推荐这么写

var b = new Array( ) //等于上式

function Foo(){

}//一般推荐这么写

var Foo = new Function() //等于上式
</code></pre><p><strong>也就是说对象都是通过函数来创建的，平常我们看到的var obj = {a:1}这个只是语法糖，其实也是通过构造函数来实现的。</strong></p>
<pre><code>var obj = new Object();
obj.a = 10;
obj.b = 20;
</code></pre><p>我们可以得到：</p>
<ul>
<li>Foo()的构造函数是Function</li>
<li>对象a的构造函数是Object</li>
<li>数组b的构造函数是Array</li>
</ul>
<p><strong>接下来就是知识点了！！快点拿小本本记下来！！！</strong></p>
<p>重点规则：</p>
<ul>
<li><p>所有的引用类型（函数，对象，数组）都是拥有对象特性，可以随意扩展属性（null除外）。</p>
</li>
<li><p>所有的引用类型都有一个__proto__属性（也称为隐式属性），其属性值是一个普通对象。</p>
</li>
<li>所有的函数都有一个prototype属性（也称为显式属性），其属性值也是一个普通对象。（Function默认的只有一个叫做constructor的属性，指向这个函数本身。如下图）<br><img src="https://upload-images.jianshu.io/upload_images/7728915-724f8d3762437719.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>例如，我们的Object（这是一个构造函数来着，所以它也是函数）的prototype就拥有许多默认的方法，如下：<br><img src="https://upload-images.jianshu.io/upload_images/7728915-3ad868616f8208f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>当我们新建一个对象，即var obj = {a:1},这个obj也拥有Object.prototype上所有的属性和方法。</li>
</ul>
<ul>
<li><strong>所有的应用类型的_proto_属性相当于它的构造函数的prototype属性</strong></li>
</ul>
<pre><code>var obj = {};
console.log(obj.__proto__===Object.prototype)   //true

var arr = [];
console.log(arr.__proto__===Array.prototype)   //true

var foo = function(){}
console.log(foo.__proto__===Function.prototype) //true
</code></pre><p>这是一条很重要的性质。请务必记住</p>
<h4 id="来聊聊那张神图吧！"><a href="#来聊聊那张神图吧！" class="headerlink" title="来聊聊那张神图吧！"></a>来聊聊那张神图吧！</h4><p>先来讲个故事：<br>从前有一个小村庄，里面生活着三个兄弟，一个叫function，一个叫array，另外一个叫object，有一家叫typeof的属性鉴定中心来宣传，说可以免费做鉴定，看出他们的父亲是谁，做完还能免费送十斤大米。</p>
<p>三兄弟开开心心的去做了，但是function的父亲和object，array的父亲(Object)却不是同一个人。</p>
<p>怎么回事？发现原来function其实是上帝的孩子!上帝的孩子也是所有人的父亲！</p>
<p>好吧我承认，编不下去了。</p>
<p>总所周知，function,array,object都属于对象。<br>对象是函数（构造函数）创建的，而函数却又是一种对象。有点绕？让我们看看下面的代码：</p>
<pre><code>console.log(typeof function(){})// function
console.log(typeof [1,2,3])  //object
console.log(typeof {a:1}) //object
</code></pre><p>明明都是object，为什么array和object的结果和function不一样呢？</p>
<p><strong>function 显得有点不合群啊，存在即合理，但肯定是有原因的。</strong></p>
<p><strong>对！函数是一种对象</strong>，但是函数却不像数组一样——你可以说数组是对象的一种，因为数组就像是对象的一个子集一样。但是函数与对象之间，却不仅仅是一种包含和被包含的关系，函数和对象之间的关系比较复杂，甚至有一点鸡生蛋蛋生鸡的逻辑。</p>
<pre><code>console.log(Function instanceof Function)//true
console.log(Function instanceof Object) //true
console.log(Object instanceof Function) //true
</code></pre><p>这个时候，你心里会在想：上面这些是什么鬼！什么东西！</p>
<p>其实我们换个角度想想，Object 是一个构造函数，其实Object 是由Function 产生的，也就是说，Object的构造函数是Function。<br>他们这种相互缠绕的关系正是我们下图所要表示的。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7728915-e657c72ff7d7ef83.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>    Function.prototype是一种对象。</p>
<pre><code>Object.__proto__ ==  Function.prototype //true
Function.prototype.__proto__ == Object.prototype //true
Function.__proto__ == Function.prototype //true
</code></pre><p>请记住：自定义函数Foo.__proto__ 指向Function.prototype，Object.__proto__指向Function.prototype</p>
<p><strong>Function,Object,Array这些构造函数的构造函数都是Function</strong></p>
<p>接下来继续看这张图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7728915-6f47ab5fc0552353.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ol>
<li>看f1,f2=new Foo()这条线</li>
</ol>
<ul>
<li>var Foo = {a:1}</li>
<li>var f1 = new Foo() //f1的构造函数是Foo</li>
<li>f1.__proto__  === Foo.prototype</li>
<li>Foo.prototype 是一个对象（里面有好多属性值啥的），所以Foo.prototype的构造函数来自Objcect</li>
<li>然后我们又规定了Object.proyotype.__proto__ = null<br>好好感受一下。</li>
</ul>
<ol start="2">
<li>o1,o2=new Object()</li>
</ol>
<ul>
<li>o1.__proto__ === Object.prototype;</li>
<li>Object 是一个构造函数，其实Object 是由Function 产生的，也就是说，Object的构造函数是Function</li>
<li>Object.__proto__ === Function.prototype</li>
<li>Function.prototype是对象，所以它的构造函数是Object<br>Function.prototype.__proto__ === Object.prototype</li>
<li>Function的构造函数还是Function,所以就有了<br>Function._ _proto__ === Function.prototype</li>
</ul>
<p>你看懂了吗？</p>
<h4 id="课后习题"><a href="#课后习题" class="headerlink" title="课后习题"></a>课后习题</h4><ul>
<li>牛刀小试</li>
</ul>
<pre><code>function Foo(name){
  this.name=name;
}
var f = new Foo(&apos;zhangsan&apos;);
f.printf = function(){
  alert(this.name);
}
f.toString();   //这个要去f._proto_.proto里面找
</code></pre><p>先在脑中好好想想这个过程！</p>
<ol>
<li>我们要找到f.toString()，首先在f中找，但是f中我们只定义了一个printf的属性，那么我们只能去f的隐式原型里面找有没有这个属性，</li>
<li>同时，Foo是f的构造函数，所以f.__proto_===Foo.prototype;<br>这里的f.__proto_和Foo.prototype都是对象。<br>Foo.prototype里面也没有这个属性；</li>
<li>继续从Foo的隐式原型里面查找；<br>同时，Foo.prototype.__proto__===Object.prototype;</li>
<li>最后注意，js中规定：Object.prototype=null;为了避免死循环。</li>
</ol>
<ul>
<li>如果看懂了上面那张图，看懂下面这张图应该也不是什么大问题了。</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/7728915-188c1b2fc607cf65.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="原型链.png"></p>
<p>上图中的“Foo.prototype”也是一个对象,它的__proto_指向哪里？<br>在说明“Foo.prototype”之前，先说一下自定义函数(我们自己建的构造函数）的prototype。自定义函数的prototype本质上就是和 var obj = {} 是一样的，都是被Object创建，所以它的_proto_指向的就是Object.prototype。</p>
<ul>
<li><p>如何准确判断一个变量是数组类型？</p>
<p> 先排除typeof；为什么？<br><img src="http://upload-images.jianshu.io/upload_images/7728915-302ab9d0baafb783.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="typeof.png"></p>
<p> 我们应该利用instanceof，用于判断引用类型属于哪个构造函数，通过原型链查找,其规则如下面所示：</p>
<p> <strong>Instanceof运算符的第一个变量是一个对象，暂时称为A；第二个变量一般是一个函数，暂时称为B</strong></p>
<p> 判断规则是：沿着A的<strong>proto</strong>这条线来找，同时沿着B的prototype这条线来找，如果两条线能找到同一个引用，即同一个对象，那么就返回true。如果找到终点还未重合，则返回false。</p>
<p> 一层一层向上查找，看arr的构造函数是不是Array。<br><img src="http://upload-images.jianshu.io/upload_images/7728915-959fdfa6b881b09e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="instanceof.png"><br>但是instanceof在某些IE版本中不正确，我们也可以用下面这种方法：<br>Array.isArray(object)<br><img src="https://upload-images.jianshu.io/upload_images/7728915-d28a3ade32c727fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="判断数组.png"></p>
</li>
</ul>
<ul>
<li><p>简述一下new一个对象的过程</p>
<p> 前提：有一个构造函数</p>
<ol>
<li>创建一个新对象</li>
<li>this指向这个新对象</li>
<li>对this赋值</li>
<li>返回this</li>
</ol>
</li>
<li><p>以下运行结果可以返回true的是</p>
<pre><code>function Book(){};
var b1 = new Book();
var b2 = new Book();
b1.__proto__ === Object.prototype
Book._proto__ === Function.prototype 
b1.__proto__ === b2.__proto__  
b1.__proto__ === Book.prototype  

//false true true true
</code></pre></li>
<li><p>写一个最完美继承的例子</p>
</li>
</ul>
<pre><code>var Car = function(color){
    this.color = color;
}
Car.prototype.sale = function(){
    console.log(this.color + &apos;色的车卖了100万&apos;)
}
var BMW = function(color){
    Car.call(this,color)
}
//需要解决的问题有
//1.拿到父类原型链上面的方法
//2.不能让构造函数执行两次
//3.引用的原型链不能按地址引用（不然子类上面的修改会影响到父类，可以使用Object.create来给做个副本）
//4.修正子类的constructor 
var __pro = Object.create(Car.prototype);//复制原型链
__pro.constructor = BMW;
BMW.prototype = __pro;
var m = new BMW(&apos;red&apos;);
m.sale()
</code></pre><p>ES6版本：</p>
<pre><code>class Car{
    constructor(color,price){
        this.color = color;
        this.price = price;
    }
    sale(){
        console.log(this.color +&apos;色的车卖了&apos;+this.price)
    }
}
    class Cruze extends Car{
        constructor(color,price){
            super(color,price);
        }
    }

    var bmw = new Cruze(&apos;red&apos;,&apos;199万&apos;);
    bmw.sale()
</code></pre><p>这系列的教程很不错：<a href="https://www.cnblogs.com/wangfupeng1988/p/3977924.html" target="_blank" rel="noopener">https://www.cnblogs.com/wangfupeng1988/p/3977924.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/20/原型与原型链/" data-id="ck35ybx6n000lnrh2kovwzhte" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JS中的按值传递和按引用问题-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/20/JS中的按值传递和按引用问题-1/" class="article-date">
  <time datetime="2019-03-20T03:47:52.000Z" itemprop="datePublished">2019-03-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JS基础/">JS基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/20/JS中的按值传递和按引用问题-1/">JS中的按值传递和按引用问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>写出输出值，并解释为什么</p>
<pre><code>function test(m){
    m = {
        v:5
    };
}
var m = {
    k:30
};
test(m);  
alert(m.v); //undefined
</code></pre><p>test函数是把m进行重写了，是重写，所以就找不到m.v了。</p>
<p>在我看来，函数传参需要分两种情况，基本类型复制后俩个变量完全独立，之后任何一方改变都不会影响另一方；引用类型复制的是引用，之后的任何一方改变都会映射到另一方。</p>
<p><strong>我们可以把ECMAScript函数的参数想象成局部变量。在向参数传递基本类型的值时，被传递的值被复制给一个局部变量（即命名参数，或者用ECMAScript的概念来说，就是arguments对象中的一个元素）。在向参数传递引用类型时，会把这个值在内存中的地址（指针）复制给一个局部变量，因此这个局部变量的变化会反映在函数的外部。</strong></p>
<p>拿一个最简单的例子来讲：</p>
<pre><code>function test(a){
    a = a * 10
}
var a = 10;
test(a);
</code></pre><p>分析一下，函数test()括号里面的a是函数arguments对象中的一个元素，只是将外面的a复制了一份值给test里面的a,对arguments里面的a进行操作，与我们在外面定义的a，互不干扰。对上面的代码进行更改：</p>
<pre><code>function test(num){
    num = num * 10;
}
var a = 10;
test(a);//10
</code></pre><p>所以上面那道题都是a有点迷惑人的嫌疑，下面的代码实现的效果和上面是一样的。外面的a将自己的值复制给test中的arguments中的num就没自己什么事了。</p>
<p>如果要把内部操作的结果给外面，也很简单，用return就好了。</p>
<pre><code>function test(num){
    num = num * 10;
    return num;
}
var a = 10;
var b = test(a);
console.log(a);//10
console.log(b);//100
</code></pre><p><strong>但是像参数传递引用类型的数值时，会把这个值在内存中的地址（指针）复制给函数的参数，因此这个局部变量的变化会反映在函数的外部。</strong><br>看下面的例子就能很明显的看出引用传递的特点了。</p>
<pre><code>var a = {
    num : 1
};
var b = a;
b.num = 2;
console.log(&apos;a&apos;,a); //{num:2}
console.log(&apos;b&apos;,b); //{num:2}
</code></pre><p>很明显，这是按引用传递，改动b就相当于改动a.</p>
<pre><code>var a = {
    num : 1
};
var b = a;
b = {};  
b.num = 3;
console.log(&apos;a&apos;,a); //{num:1}
console.log(&apos;b&apos;,b); //{num:3}
</code></pre><p>此时 b = {}开辟了新的内存地址。</p>
<p>比较一下下面两段代码的不同：<br>示例一：</p>
<pre><code>function test(n){
    n = {
        k : 2
    }
}

var m = {
    v : 100
}
test(m);
console.log(m.v);//100
console.log(m.k);//undefined
</code></pre><p>示例二：</p>
<pre><code>function test(n){
    n.k = 20;
}

var m = {
    v : 100
}
test(m);
console.log(m.v);//100
console.log(m.k);//20
</code></pre><p>示例一：我们注意到test中对参数进行了重写，<br>    n = { k : 2 }相当于 n = {},n.k = 2;<br>    也就是说本来是test中的参数n和外面的m本来是指向同一个地址的，但是，n = { k : 2 }重写了，指向了另外一个新的地址，并在这个新的地址这里给k赋值了。</p>
<p>示例二： n和m指向同一个地址，并且n只是添加属性并没有重写，所以两个属性都是存在的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/20/JS中的按值传递和按引用问题-1/" data-id="ck35ybx6h000cnrh2q9x3ty63" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-vue源码解读" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/13/vue源码解读/" class="article-date">
  <time datetime="2019-03-13T12:34:43.000Z" itemprop="datePublished">2019-03-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/京城一灯/">京城一灯</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/13/vue源码解读/">前端工程化必备linux知识</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="远程登陆linux"><a href="#远程登陆linux" class="headerlink" title="远程登陆linux"></a>远程登陆linux</h4><h5 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h5><ul>
<li><p>putty Xshell  类似，不过putty是开源的，Xshell是商业性的。</p>
</li>
<li><p>cmder终端环境下使用ssh命令</p>
</li>
</ul>
<h4 id="linux基本知识"><a href="#linux基本知识" class="headerlink" title="linux基本知识"></a>linux基本知识</h4><h5 id="什么是home目录？"><a href="#什么是home目录？" class="headerlink" title="什么是home目录？"></a>什么是home目录？</h5><p>1、家目录是用户的/home目录，每个用户都有自己的文件夹<br>其分为两种情况<br>(1)、普通用户</p>
<pre><code>/home/haha (haha是设置的用户名，也可以自己设置)
</code></pre><p>(2)、root用户</p>
<pre><code>/root
</code></pre><p>直接在命令行敲cd 就会进入到当前用户的home目录下。</p>
<ol start="2">
<li>根目录是指最上层的目录，即“/”<br>根目录下有很多目录：</li>
</ol>
<p>dev  home  lib64  mnt    opt   root  sbin  sys  usr<br>boot  etc  lib   media  newFS  proc  run   srv   tmp  var</p>
<ol start="3">
<li><p>如何进行普通用户和root用户的切换</p>
<p>普通用户→root用户</p>
<p>   su root 输入密码</p>
<p>root用户→普通用户</p>
<p>   su haha(haha为用户名)</p>
</li>
</ol>
<h5 id="重要linux命令"><a href="#重要linux命令" class="headerlink" title="重要linux命令"></a>重要linux命令</h5><ol>
<li>行编辑器 vi/vim </li>
</ol>
<p>基本上 vi/vim 共分为三种模式，分别是命令模式（Command mode），输入模式（Insert mode）和底线命令模式（Last line mode）。 这三种模式的作用分别是：</p>
<p><strong>命令模式：</strong><br>用户刚刚启动 vi/vim，便进入了命令模式。</p>
<p>此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。</p>
<p>以下是常用的几个命令：</p>
<p>i 切换到输入模式，以输入字符。<br>x 删除当前光标所在处的字符。<br>: 切换到底线命令模式，以在最底一行输入命令。</p>
<p>也就是说，<strong>若想要编辑文本：启动Vim，进入了命令模式，按下i，切换到输入模式。</strong></p>
<p><strong>输入模式</strong><br>在命令模式下按下i就进入了输入模式。</p>
<p>ESC，退出输入模式，切换到命令模式</p>
<p><strong>底线模式</strong></p>
<p>在命令模式下按下:（英文冒号）就进入了底线命令模式。</p>
<p>底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。</p>
<p>一般用  w (保存文件)  q(退出程序)</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7728915-0f3bf3b9bbcad65a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>密密麻麻的有点恐怖。</p>
<ol start="2">
<li>服务管理命令 systemctl </li>
</ol>
<p>拿httpd.service来举例：</p>
<p>systemctl start httpd.service 启动httpd.service服务<br>systemctl enable nfs-server.service  设置httpd.service服务开机自启动<br>systemctl disable nfs-server.service  设置httpd.service服务停止开机自启动<br>systemctl status nfs-server.service   查看服务当前状态<br>systemctl stop nfs-server.service 停止httpd.service服务<br>systemctl 查看所有服务</p>
<ol start="3">
<li>网络管理命令 ifconfig、ip命令、router </li>
</ol>
<p><strong>ifconfig(interface config)</strong><br>一般就用ipconfig来查看一些ip地址等的信息，其他的详细内容可以参考博文：<a href="https://www.cnblogs.com/mmx8861/p/9277108.html" target="_blank" rel="noopener">https://www.cnblogs.com/mmx8861/p/9277108.html</a></p>
<p><strong>ip</strong><br>ip命令其实是一个网络配置工具箱。linux的ip命令和ifconfig类似，但前者功能更强大，并旨在取代后者。<br>ip addr  查看ip地址<br>其他详细内容可以参考博文：<br><a href="https://linux.cn/article-3144-1.html" target="_blank" rel="noopener">https://linux.cn/article-3144-1.html</a></p>
<p><strong>router</strong></p>
<p>使用route 命令可以查看 Linux 内核路由表。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7728915-dd893522747f3f91.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>rooute命令的输出项说明</p>
<p>Destination    目标网段或者主机<br>Gateway       网关地址， ”*” 表示目标是本主机所属的网络，不需要路由<br>Genmask    网络掩码<br>Iface    该路由表项对应的输出接口</p>
<ol start="4">
<li>命令行下载命令 curl、wget </li>
</ol>
<p>wget -c url  加了-c  断点续传，对于我们下载大文件时突然由于网络等原因中断非常有帮助，我们可以继续接着下载而不是重新下载一个文件。需要继续中断的下载时可以使用-c参数。 </p>
<ol start="5">
<li>怎样查看Linux命令的帮助</li>
</ol>
<p>xxx(某某命令)  -h<br>就会把一些相关参数和具体应用都显示出来。<br> man xxx(某某命令)</p>
<ol start="6">
<li><p>查看服务器系统信息</p>
<p>lsb release -a </p>
</li>
<li>在终端下不小心ctrl+s了怎么办？</li>
</ol>
<p>ctrl+s实际上是把终端挂起了，这个时候只需要ctrl+q就行了。</p>
<p><strong>一些常见的快捷方式</strong></p>
<p>ctrl+c 结束正在运行的程序【ping、telnet等】<br>ctrl+d 结束输入或退出shell<br>ctrl+s 暂停屏幕输出<br>ctrl+q 恢复屏幕输出<br>ctrl+l 清屏，等同于Clear<br>ctrl+a/ctrl+e 快速移动光标到行首/行尾</p>
<h4 id="进程-线程-协程"><a href="#进程-线程-协程" class="headerlink" title="进程 线程 协程"></a>进程 线程 协程</h4><p>一篇比较好的讲解进程和线程的博文：<br><a href="http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html</a></p>
<ul>
<li><p>双击了一个exe，就产生了一个进程。<br>进程的目的就是担当分配系统资源（CPU时间、内存）的实体<br>进程需要进行一系列的运算。如果CPU是单核的，那么每次只能运行一个进程。（一核同一时间能运行一个进程）</p>
</li>
<li><p>线程是操作系统能够进行运算调度的最小单位 。</p>
</li>
<li><p>协程是一种用户态的轻量级线程，无法利用多核资源。正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。<br><img src="https://upload-images.jianshu.io/upload_images/7728915-65cc004910a083ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
</li>
<li><p>IO密集型应用的发展：多进程-&gt;多线程-&gt;事件驱动-&gt;协程。IO密集型的任务一般涉及网络，磁盘IO。大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）。对于IO密集型任务，任务越多，CPU效率越高，但也有一个限度。常见的大部分任务都是IO密集型任务，比如Web应用。<br>IO密集型应用的发展: 多进程-&gt;多线程-&gt;事件驱动-&gt;协程</p>
</li>
<li><p>CPU密集型（计算密集型）：消耗CPU资源，比如计算圆周率、对视频进行高清解码等任务。<br>CPU密集型程序适合C语言多线程，I/O密集型适合脚本语言开发的多线程。<br>CPU密集型应用的发展:多进程-&gt;多线程 </p>
</li>
<li><p>调度和切换的时间：进程 &gt; 线程 &gt; 协程</p>
</li>
<li><p>Linux探秘之用户态和内核态<br><a href="https://www.cnblogs.com/bakari/p/5520860.html" target="_blank" rel="noopener">https://www.cnblogs.com/bakari/p/5520860.html</a><br><img src="https://upload-images.jianshu.io/upload_images/7728915-56727aea58896b5c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Unix/Linux的体系架构.png"><br>如上图所示，从宏观上来看，Linux操作系统的体系架构分为<code>用户态</code>和<code>内核态</code>（或者用户空间和内核）。内核从本质上看是一种软件——控制计算机的硬件资源，并提供上层应用程序运行的环境。<strong>用户态即上层应用程序的活动空间</strong>，应用程序的执行必须依托于内核提供的资源，包括CPU资源、存储资源、I/O资源等。为了使上层应用能够访问到这些资源，内核必须为上层应用提供访问的接口：即系统调用。</p>
<p>Shell是一个特殊的应用程序，俗称命令行，本质上是一个命令解释器，它下通系统调用，上通各种应用，通常充当着一种“胶水”的角色，来连接各个小功能程序，让不同程序能够以一个清晰的接口协同工作，从而增强各个程序的功能。同时，Shell是可编程的，它可以执行符合Shell语法的文本，这样的文本称为Shell脚本，通常短短的几行Shell脚本就可以实现一个非常大的功能，原因就是这些Shell语句通常都对系统调用做了一层封装。为了方便用户和系统交互，一般，一个Shell对应一个终端，终端是一个硬件设备，呈现给用户的是一个图形化窗口。我们可以通过这个窗口输入或者输出文本。这个文本直接传递给shell进行分析解释，然后执行。</p>
</li>
<li><p>总结<br>操作系统的设计，可以归结为三点：<br>1、以多进程形式，允许多个任务同时运行；<br>2、以多线程形式，允许单个任务分成不同的部分运行；<br>3、提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源<br>4、进程和线程的资源共享如下图：<br><img src="https://upload-images.jianshu.io/upload_images/7728915-9034121270681a2a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
</li>
</ul>
<h5 id="Linux进程管理相关命令"><a href="#Linux进程管理相关命令" class="headerlink" title="Linux进程管理相关命令"></a>Linux进程管理相关命令</h5><ol>
<li>top 命令详解 </li>
</ol>
<p>top命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况top，相当于windows下面的资源管理器。</p>
<p><a href="https://www.cnblogs.com/sunshuhai/p/6250514.html" target="_blank" rel="noopener">https://www.cnblogs.com/sunshuhai/p/6250514.html</a></p>
<ol start="2">
<li>ps 命令 详解</li>
</ol>
<p>ps是显示瞬间进程的状态，并不动态连续；如果想对进程进行实时监控应该用top命令。</p>
<p>请强行记住<strong>ps aux</strong>这个命令行组合显示所有包含其他使用者的行程<br><a href="http://www.runoob.com/linux/linux-comm-ps.html" target="_blank" rel="noopener">http://www.runoob.com/linux/linux-comm-ps.html</a></p>
<p>1号进程是所有其他进程的父进程，所以不能被杀掉。<br>一旦杀死了父进程，系统就会崩溃。</p>
<p>grep是筛选命令使用正则表达式搜索文本，匹配你要找的进程</p>
<p>ps aux | grep sshd   查到sshd的进程</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7728915-fe2d80d00977de4b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>最后一行包括了grep的不需要管，因为这是因为我们的搜索才存在的进程。<br>既然有两个进程，我们就应该区分哪一个是子进程，哪一个是父进程，杀死进程的时候只要杀父进程，子进程也会跟着完蛋。（<strong>哪个PID小哪个就最有可能是父进程</strong>）</p>
<p>详情可以参考博文：<br><a href="https://www.cnblogs.com/robertoji/p/5555449.html" target="_blank" rel="noopener">https://www.cnblogs.com/robertoji/p/5555449.html</a></p>
<ol start="3">
<li>kill、pkill 命令及使用注意事项 </li>
</ol>
<p>kill PID  杀死进程<br>kill -9 PID  彻底杀死进程</p>
<p>kill像linux操作系统发信号，9号信号就是强制关闭一个进程，不加-9就是让进程自行退出。</p>
<ol start="4">
<li>w 命令 </li>
</ol>
<p>w是who的简写，显示当前用户</p>
<h5 id="Linux网络管理相关命令"><a href="#Linux网络管理相关命令" class="headerlink" title="Linux网络管理相关命令"></a>Linux网络管理相关命令</h5><ol>
<li><p>查看和配置网络基本信息 ifconfig、ip </p>
</li>
<li><p>重启网卡 </p>
</li>
<li><p>查看路由配置 router </p>
</li>
<li><p>排查网络故障 traceroute</p>
</li>
</ol>
<p>Linux traceroute命令用于显示数据包到主机间的路径。（追踪通信过程中经过的路由）<br>traceroute指令让你追踪网络数据包的路由途径，预设数据包大小是40Bytes，用户可另行设置。</p>
<p><strong>5. 怎样找到占用网络端口的进程</strong><br> ss命令、netstat命令<br>ss命令与netstat类似<br> ss -an  : 端口也可以一起显示（ -a:  all， -n:  numeric         【不解析服务名称】-p:  progress【查看使用某个网络端口号的进程】）</p>
<p>如果要查找使用22端口的进程应该怎么做？</p>
<p>ss -anp | grep :22<br>就能得到我们要的进程了。<br><img src="https://upload-images.jianshu.io/upload_images/7728915-9768cb7cd807084f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h4 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h4><p>linux命令大全<br><a href="http://www.runoob.com/linux/linux-command-manual.html" target="_blank" rel="noopener">http://www.runoob.com/linux/linux-command-manual.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/13/vue源码解读/" data-id="ck35ybx6o000onrh2zbxdc2sr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-前端工程化必备linux知识" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/13/前端工程化必备linux知识/" class="article-date">
  <time datetime="2019-03-13T12:34:43.000Z" itemprop="datePublished">2019-03-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/京城一灯/">京城一灯</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/13/前端工程化必备linux知识/">前端工程化必备linux知识</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="远程登陆linux"><a href="#远程登陆linux" class="headerlink" title="远程登陆linux"></a>远程登陆linux</h4><h5 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h5><ul>
<li><p>putty Xshell  类似，不过putty是开源的，Xshell是商业性的。</p>
</li>
<li><p>cmder终端环境下使用ssh命令</p>
</li>
</ul>
<h4 id="linux基本知识"><a href="#linux基本知识" class="headerlink" title="linux基本知识"></a>linux基本知识</h4><h5 id="什么是home目录？"><a href="#什么是home目录？" class="headerlink" title="什么是home目录？"></a>什么是home目录？</h5><p>1、家目录是用户的/home目录，每个用户都有自己的文件夹<br>其分为两种情况<br>(1)、普通用户</p>
<pre><code>/home/haha (haha是设置的用户名，也可以自己设置)
</code></pre><p>(2)、root用户</p>
<pre><code>/root
</code></pre><p>直接在命令行敲cd 就会进入到当前用户的home目录下。</p>
<ol start="2">
<li>根目录是指最上层的目录，即“/”<br>根目录下有很多目录：</li>
</ol>
<p>dev  home  lib64  mnt    opt   root  sbin  sys  usr<br>boot  etc  lib   media  newFS  proc  run   srv   tmp  var</p>
<ol start="3">
<li><p>如何进行普通用户和root用户的切换</p>
<p>普通用户→root用户</p>
<p>   su root 输入密码</p>
<p>root用户→普通用户</p>
<p>   su haha(haha为用户名)</p>
</li>
</ol>
<h5 id="重要linux命令"><a href="#重要linux命令" class="headerlink" title="重要linux命令"></a>重要linux命令</h5><ol>
<li>行编辑器 vi/vim </li>
</ol>
<p>基本上 vi/vim 共分为三种模式，分别是命令模式（Command mode），输入模式（Insert mode）和底线命令模式（Last line mode）。 这三种模式的作用分别是：</p>
<p><strong>命令模式：</strong><br>用户刚刚启动 vi/vim，便进入了命令模式。</p>
<p>此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。</p>
<p>以下是常用的几个命令：</p>
<p>i 切换到输入模式，以输入字符。<br>x 删除当前光标所在处的字符。<br>: 切换到底线命令模式，以在最底一行输入命令。</p>
<p>也就是说，<strong>若想要编辑文本：启动Vim，进入了命令模式，按下i，切换到输入模式。</strong></p>
<p><strong>输入模式</strong><br>在命令模式下按下i就进入了输入模式。</p>
<p>ESC，退出输入模式，切换到命令模式</p>
<p><strong>底线模式</strong></p>
<p>在命令模式下按下:（英文冒号）就进入了底线命令模式。</p>
<p>底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。</p>
<p>一般用  w (保存文件)  q(退出程序)</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g91audv5kyj312e0u0e81.jpg" alt></p>
<p>密密麻麻的有点恐怖。</p>
<ol start="2">
<li>服务管理命令 systemctl </li>
</ol>
<p>拿httpd.service来举例：</p>
<p>systemctl start httpd.service 启动httpd.service服务<br>systemctl enable nfs-server.service  设置httpd.service服务开机自启动<br>systemctl disable nfs-server.service  设置httpd.service服务停止开机自启动<br>systemctl status nfs-server.service   查看服务当前状态<br>systemctl stop nfs-server.service 停止httpd.service服务<br>systemctl 查看所有服务</p>
<ol start="3">
<li>网络管理命令 ifconfig、ip命令、router </li>
</ol>
<p><strong>ifconfig(interface config)</strong><br>一般就用ipconfig来查看一些ip地址等的信息，其他的详细内容可以参考博文：<a href="https://www.cnblogs.com/mmx8861/p/9277108.html" target="_blank" rel="noopener">https://www.cnblogs.com/mmx8861/p/9277108.html</a></p>
<p><strong>ip</strong><br>ip命令其实是一个网络配置工具箱。linux的ip命令和ifconfig类似，但前者功能更强大，并旨在取代后者。<br>ip addr  查看ip地址<br>其他详细内容可以参考博文：<br><a href="https://linux.cn/article-3144-1.html" target="_blank" rel="noopener">https://linux.cn/article-3144-1.html</a></p>
<p><strong>router</strong></p>
<p>使用route 命令可以查看 Linux 内核路由表。</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g91bjga9n5j30yc056myl.jpg" alt><br>rooute命令的输出项说明</p>
<p>Destination    目标网段或者主机<br>Gateway       网关地址， ”*” 表示目标是本主机所属的网络，不需要路由<br>Genmask    网络掩码<br>Iface    该路由表项对应的输出接口</p>
<ol start="4">
<li>命令行下载命令 curl、wget </li>
</ol>
<p>wget -c url  加了-c  断点续传，对于我们下载大文件时突然由于网络等原因中断非常有帮助，我们可以继续接着下载而不是重新下载一个文件。需要继续中断的下载时可以使用-c参数。 </p>
<ol start="5">
<li>怎样查看Linux命令的帮助</li>
</ol>
<p>xxx(某某命令)  -h<br>就会把一些相关参数和具体应用都显示出来。<br> man xxx(某某命令)</p>
<ol start="6">
<li><p>查看服务器系统信息</p>
<p>lsb release -a </p>
</li>
<li>在终端下不小心ctrl+s了怎么办？</li>
</ol>
<p>ctrl+s实际上是把终端挂起了，这个时候只需要ctrl+q就行了。</p>
<p><strong>一些常见的快捷方式</strong></p>
<p>ctrl+c 结束正在运行的程序【ping、telnet等】<br>ctrl+d 结束输入或退出shell<br>ctrl+s 暂停屏幕输出<br>ctrl+q 恢复屏幕输出<br>ctrl+l 清屏，等同于Clear<br>ctrl+a/ctrl+e 快速移动光标到行首/行尾</p>
<h4 id="进程-线程-协程"><a href="#进程-线程-协程" class="headerlink" title="进程 线程 协程"></a>进程 线程 协程</h4><p>一篇比较好的讲解进程和线程的博文：<br><a href="http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html</a></p>
<ul>
<li><p>双击了一个exe，就产生了一个进程。<br>进程的目的就是担当分配系统资源（CPU时间、内存）的实体<br>进程需要进行一系列的运算。如果CPU是单核的，那么每次只能运行一个进程。（一核同一时间能运行一个进程）</p>
</li>
<li><p>线程是操作系统能够进行运算调度的最小单位 。</p>
</li>
<li><p>协程是一种用户态的轻量级线程，无法利用多核资源。正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g91bkk3ahxj310y0qmtnd.jpg" alt></p>
</li>
<li><p>IO密集型应用的发展：多进程-&gt;多线程-&gt;事件驱动-&gt;协程。IO密集型的任务一般涉及网络，磁盘IO。大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）。对于IO密集型任务，任务越多，CPU效率越高，但也有一个限度。常见的大部分任务都是IO密集型任务，比如Web应用。<br>IO密集型应用的发展: 多进程-&gt;多线程-&gt;事件驱动-&gt;协程</p>
</li>
<li><p>CPU密集型（计算密集型）：消耗CPU资源，比如计算圆周率、对视频进行高清解码等任务。<br>CPU密集型程序适合C语言多线程，I/O密集型适合脚本语言开发的多线程。<br>CPU密集型应用的发展:多进程-&gt;多线程 </p>
</li>
<li><p>调度和切换的时间：进程 &gt; 线程 &gt; 协程</p>
</li>
<li><p>Linux探秘之用户态和内核态<br><a href="https://www.cnblogs.com/bakari/p/5520860.html" target="_blank" rel="noopener">https://www.cnblogs.com/bakari/p/5520860.html</a><br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g91blbjvkcj30lq0k8diq.jpg" alt="Unix/Linux的体系架构.png"><br>如上图所示，从宏观上来看，Linux操作系统的体系架构分为<code>用户态</code>和<code>内核态</code>（或者用户空间和内核）。内核从本质上看是一种软件——控制计算机的硬件资源，并提供上层应用程序运行的环境。<strong>用户态即上层应用程序的活动空间</strong>，应用程序的执行必须依托于内核提供的资源，包括CPU资源、存储资源、I/O资源等。为了使上层应用能够访问到这些资源，内核必须为上层应用提供访问的接口：即系统调用。</p>
<p>Shell是一个特殊的应用程序，俗称命令行，本质上是一个命令解释器，它下通系统调用，上通各种应用，通常充当着一种“胶水”的角色，来连接各个小功能程序，让不同程序能够以一个清晰的接口协同工作，从而增强各个程序的功能。同时，Shell是可编程的，它可以执行符合Shell语法的文本，这样的文本称为Shell脚本，通常短短的几行Shell脚本就可以实现一个非常大的功能，原因就是这些Shell语句通常都对系统调用做了一层封装。为了方便用户和系统交互，一般，一个Shell对应一个终端，终端是一个硬件设备，呈现给用户的是一个图形化窗口。我们可以通过这个窗口输入或者输出文本。这个文本直接传递给shell进行分析解释，然后执行。</p>
</li>
<li><p>总结<br>操作系统的设计，可以归结为三点：<br>1、以多进程形式，允许多个任务同时运行；<br>2、以多线程形式，允许单个任务分成不同的部分运行；<br>3、提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源<br>4、进程和线程的资源共享如下图：<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g91apfd7gxj30io0bmwji.jpg" alt="image.png"></p>
</li>
</ul>
<h5 id="Linux进程管理相关命令"><a href="#Linux进程管理相关命令" class="headerlink" title="Linux进程管理相关命令"></a>Linux进程管理相关命令</h5><ol>
<li>top 命令详解 </li>
</ol>
<p>top命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况top，相当于windows下面的资源管理器。</p>
<p><a href="https://www.cnblogs.com/sunshuhai/p/6250514.html" target="_blank" rel="noopener">https://www.cnblogs.com/sunshuhai/p/6250514.html</a></p>
<ol start="2">
<li>ps 命令 详解</li>
</ol>
<p>ps是显示瞬间进程的状态，并不动态连续；如果想对进程进行实时监控应该用top命令。</p>
<p>请强行记住<strong>ps aux</strong>这个命令行组合显示所有包含其他使用者的行程<br><a href="http://www.runoob.com/linux/linux-comm-ps.html" target="_blank" rel="noopener">http://www.runoob.com/linux/linux-comm-ps.html</a></p>
<p>1号进程是所有其他进程的父进程，所以不能被杀掉。<br>一旦杀死了父进程，系统就会崩溃。</p>
<p>grep是筛选命令使用正则表达式搜索文本，匹配你要找的进程</p>
<p>ps aux | grep sshd   查到sshd的进程</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7728915-fe2d80d00977de4b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>最后一行包括了grep的不需要管，因为这是因为我们的搜索才存在的进程。<br>既然有两个进程，我们就应该区分哪一个是子进程，哪一个是父进程，杀死进程的时候只要杀父进程，子进程也会跟着完蛋。（<strong>哪个PID小哪个就最有可能是父进程</strong>）</p>
<p>详情可以参考博文：<br><a href="https://www.cnblogs.com/robertoji/p/5555449.html" target="_blank" rel="noopener">https://www.cnblogs.com/robertoji/p/5555449.html</a></p>
<ol start="3">
<li>kill、pkill 命令及使用注意事项 </li>
</ol>
<p>kill PID  杀死进程<br>kill -9 PID  彻底杀死进程</p>
<p>kill像linux操作系统发信号，9号信号就是强制关闭一个进程，不加-9就是让进程自行退出。</p>
<ol start="4">
<li>w 命令 </li>
</ol>
<p>w是who的简写，显示当前用户</p>
<h5 id="Linux网络管理相关命令"><a href="#Linux网络管理相关命令" class="headerlink" title="Linux网络管理相关命令"></a>Linux网络管理相关命令</h5><ol>
<li><p>查看和配置网络基本信息 ifconfig、ip </p>
</li>
<li><p>重启网卡 </p>
</li>
<li><p>查看路由配置 router </p>
</li>
<li><p>排查网络故障 traceroute</p>
</li>
</ol>
<p>Linux traceroute命令用于显示数据包到主机间的路径。（追踪通信过程中经过的路由）<br>traceroute指令让你追踪网络数据包的路由途径，预设数据包大小是40Bytes，用户可另行设置。</p>
<p><strong>5. 怎样找到占用网络端口的进程</strong><br> ss命令、netstat命令<br>ss命令与netstat类似<br> ss -an  : 端口也可以一起显示（ -a:  all， -n:  numeric         【不解析服务名称】-p:  progress【查看使用某个网络端口号的进程】）</p>
<p>如果要查找使用22端口的进程应该怎么做？</p>
<p>ss -anp | grep :22<br>就能得到我们要的进程了。<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g91aqoyuxwj30z204gwfv.jpg" alt="image.png"></p>
<h4 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h4><p>linux命令大全<br><a href="http://www.runoob.com/linux/linux-command-manual.html" target="_blank" rel="noopener">http://www.runoob.com/linux/linux-command-manual.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/13/前端工程化必备linux知识/" data-id="ck35ybx6p000pnrh21r1laqql" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-性能优化启示录" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/13/性能优化启示录/" class="article-date">
  <time datetime="2019-03-13T06:47:16.000Z" itemprop="datePublished">2019-03-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/京城一灯/">京城一灯</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/13/性能优化启示录/">性能优化启示录</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="为什么要进行性能优化"><a href="#为什么要进行性能优化" class="headerlink" title="为什么要进行性能优化"></a>为什么要进行性能优化</h3><ul>
<li><p>57%的⽤户更在乎⽹⻚在3秒内是否完成加载</p>
</li>
<li><p>52%的在线⽤户认为⽹⻚打开速度影响到他们对⽹站的忠实度</p>
</li>
<li><p>每慢1秒造成⻚⾯ PV 降低11%，⽤户满意度也随之降低降低16%</p>
</li>
<li><p>近半数移动⽤户因为在10秒内仍未打开⻚⾯从⽽放弃。</p>
</li>
</ul>
<h3 id="性能优化学徒工"><a href="#性能优化学徒工" class="headerlink" title="性能优化学徒工"></a>性能优化学徒工</h3><h4 id="雅⻁军规践⾏"><a href="#雅⻁军规践⾏" class="headerlink" title="雅⻁军规践⾏"></a>雅⻁军规践⾏</h4><ul>
<li><p>html数量控制<br>能尽量用CSS解决的就用CSS解决。（阴影，渐变）</p>
</li>
<li><p>压缩，合并，MD5，CDN<br>接下来请大家思考一个问题，为什么CDN对于前端这么重要？</p>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/7728915-6c06843da71d4c36.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ul>
<li>还有一个很重要的点就是离线缓存<br>打开谷歌控制台的application<br><img src="https://upload-images.jianshu.io/upload_images/7728915-e8efcd9739ac206f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="application"></li>
</ul>
<p>localStorage存储本地数据</p>
<pre><code>//需求是什么？
//假设我们需要请求a.xx3322.js
//在本地存储localstorage存储key为a.js,对应的value是a.xx3322.js
//key为a.xx3322.js,对应的value就是我们的目标js代码
//所以就不需要&lt;script src = &quot;a.xx3322.js&quot;&gt;
//可以用下面代码来实现

//webpack打包出来
var res = {
    &quot;a.js&quot;:&quot;a.xx3322.js&quot;
}

function activePage(){
    for(let item of res){
        const js = localStorage[item.key]
        //如果本地没有发请求，再发一次请求缓存
        //本地存在的话，就要判断一下当前的版本号
        //更新我们的资源
        if(js == item.value){
            eval(js)
        }else{
            fetch(item.value).then(function(res){
                localStorage[&apos;a.js&apos;] = &quot;a.xx3322.js&quot;;
                localStorage[&apos;a.xx3322.js&apos;] = res;
            })
        }
    }

}
activePage();
</code></pre><p><strong>现在我们可以使用basket.js来实现上述代码的功能</strong></p>
<p><a href="https://github.com/addyosmani/basket.js" target="_blank" rel="noopener">https://github.com/addyosmani/basket.js</a><br><a href="http://www.wenjiangs.com/article/basket-js.html" target="_blank" rel="noopener">http://www.wenjiangs.com/article/basket-js.html</a><br>使用basket.js这个库就能轻松管理了。</p>
<p>简单来说 Basket.js 是一个脚本缓存器，使用本地储存 localStorage 缓存 JavaScript 文件，如果脚本以前在本地缓存过，那么他将会被快速的加载到页面中，如果没有缓存过，那么就使用 XHR 异步加载到页面中</p>
<p>HTML5 规范建议存储限额为 5MB 的本地存储，但浏览器可以实现他们自己的配额，如果他们希望。如果超出了配额，浏览器可能无法在缓存中存储项目。如果发生这种情况，Bask.js 将从最旧的缓存中删除条目，然后重试。有些像 Opera 这样的浏览器会要求用户在超过设定阈值时增加配额。</p>
<p><strong>配合使用前端离线缓存方案 localForage</strong></p>
<h4 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h4><p><strong>缓存的优先级</strong><br>cache-control &gt; expire &gt; etag &gt;  last-modified<br><img src="https://upload-images.jianshu.io/upload_images/7728915-16c0882ff66e467c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>他们的关系面试一定会问到。<br>回去需要用nginx体现一下</p>
<h4 id="网站协议"><a href="#网站协议" class="headerlink" title="网站协议"></a>网站协议</h4><p>HTTP2协议</p>
<ul>
<li><strong>HTTP2协议的特点</strong>：</li>
<li><strong>使用二进制格式传输，更高效、更紧凑。</strong><br>TTP 2.0 中所有加强性能的核心点在于此。在之前的 HTTP 版本中，我们是通过文本的方式传输数据。在 HTTP 2.0 中引入了新的编码机制，所有传输的数据都会被分割，并采用二进制格式编码。</li>
<li><p><strong>对报头压缩，降低开销。</strong><br>在 HTTP 1.X 中，我们使用文本的形式传输 header，在 header 携带 cookie 的情况下，可能每次都需要重复传输几百到几千的字节。</p>
<p>在 HTTP 2.0 中，使用了 HPACK 压缩格式对传输的 header 进行编码，减少了 header 的大小。并在两端维护了索引表，用于记录出现过的 header ，后面在传输过程中就可以传输已经记录过的 header 的键名，对端收到数据后就可以通过键名找到对应的值。</p>
</li>
<li><p><strong>多路复用，一个网络连接实现并行请求。</strong><br>在 HTTP 2.0 中，有两个非常重要的概念，分别是帧（frame）和流（stream）。</p>
<p>帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。</p>
<p>多路复用，就是在一个 TCP 连接中可以存在多条流。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。</p>
<p>HTTP/2对同⼀域名下所有请求都是基于流，也就是说同⼀域名不管访问多少⽂件，也只建⽴⼀路连接。同样Apache的最⼤连接数为300，因为有了这个新特性，最⼤的并发就可以提升到300，⽐原来提升了6倍！（本http1.x的话每个用户可能就会占据5-6个请求）</p>
</li>
</ul>
<ul>
<li><p><strong>服务器主动推送，减少请求的延迟 。</strong><br>在 HTTP 2.0 中，服务端可以在客户端某个请求后，主动推送其他资源。</p>
<p>可以想象以下情况，某些资源客户端是一定会请求的，这时就可以采取服务端 push 的技术，提前给客户端推送必要的资源，这样就可以相对减少一点延迟时间。当然在浏览器兼容的情况下你也可以使用 prefetch 。</p>
</li>
<li><strong>默认使用加密。</strong></li>
</ul>
<h4 id="小字为先"><a href="#小字为先" class="headerlink" title="小字为先"></a>小字为先</h4><p>性能优化其实就可以用这四个字来概括，“小字为先” ，也就是<strong>将大的东西变小</strong></p>
<h3 id="渲染中性能优化"><a href="#渲染中性能优化" class="headerlink" title="渲染中性能优化"></a>渲染中性能优化</h3><h4 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h4><p><strong>先来了解一下开发者工具下中的隐藏技能</strong></p>
<hr>
<p>控制台下面有个rendering的选项(如果没有的话可以在上面的performance右边的工具栏选项选择more tools中的rendering进行添加)</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7728915-ada37e17eb7ac4b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><code>Paint Flashing</code> 高亮显示网页中需要被重绘的部分。<br><code>Layer Borders</code> 显示Layer边界。<br><code>FPS Meter</code> 每一秒的帧细节，帧速率的分布信息和GPU的内存使用情况。<br><img src="https://upload-images.jianshu.io/upload_images/7728915-9b8cf9a980a50315.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><code>Scrolling Performance Issues</code> 分析鼠标滚动时的性能问题，会显示使屏幕滚动变慢的区域。<br><code>Emulate CSS Media</code> 仿真CSS媒体类型，查看不同的设备上CSS样式效果，可能的媒体类型选项有print、screen。</p>
<p>将paint flashing选项打勾之后点击刷新的时候可以看到页面绿了一下，正是因为这是网页中需要被重绘的部分。<br>上个代码(重点部分)</p>
<pre><code>&lt;div class=&quot;container&quot;&gt;
    &lt;div class=&quot;ball&quot; id=&quot;ball&quot;&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;script&gt;
    var ball = document.getElementById(&apos;ball&apos;);
    ball.classList.add(&apos;ball&apos;);
    ball.classList.add(&apos;ball-running&apos;);

&lt;/script&gt;

&lt;style&gt;
    .container{
        position: relative;
        min-height: 400px;
    }

    .ball{
        position: absolute;
        top: 0;
        left: 0;
        width: 100px;
        height: 100px;
        background-color: blueviolet;
        border-radius: 50%;
        box-shadow: 0 0 5px rgba(245, 172, 172, 0.75)
    }
    .ball-running{
        animation: run-around 4s infinite;
    }
    @keyframes run-around {
        0%{
            top: 0;
            left: 0;
        }
        25%{
            top: 0;
            left: 200px;
        }
        50%{
            top: 200px;
            left: 200px;
        }
        75%{
            top: 200px;
            left: 0;
        }
    }
&lt;/style&gt;
</code></pre><p>上面主要就是实现一个小球运动的效果，当我们已经在rendering里面选中了paint flashing的时候，我们可以看到小球运动起来的效果是外面包裹着一层绿色，说明这是要进行重绘的区域<br><img src="https://upload-images.jianshu.io/upload_images/7728915-57dd4d2167d3365f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>使用Chrome DevTools的performance面板可以记录和分析页面在运行时的所有活动。<br><a href="https://www.cnblogs.com/xiaohuochai/p/9182710.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiaohuochai/p/9182710.html</a><br><img src="https://upload-images.jianshu.io/upload_images/7728915-29d8f3ca4a7502bf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><code>loading</code>:加载时间<br><code>scripting</code>:脚本执行时间<br><code>rendering</code>:重排时间<br><code>painting</code>:重绘时间<br><code>idle</code>:空闲时间，网站性能越好，空闲时间越长</p>
<p><strong>网站的渲染流程</strong></p>
<hr>
<p>将上面的图从summary切换到event log</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7728915-59359ef8354c1cc1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>event log按照时间先后来排序<br>可以看到网站的渲染流程是这样的：</p>
<ol>
<li>获取DOM进行分层</li>
<li>对每个图层节点进行样式的计算 Recalculate Style</li>
<li>为每个对应的节点图形和位置 重排Layout</li>
<li>对每个节点进行绘制并添加到图层位图中 Paint<br>(并不是每个图层都会GPU进行参与)<br>只有Composite Layers才会让GPU参与</li>
<li>将这个位图上传至GPU 旋转、缩放、偏移、修改透明</li>
</ol>
<p>所以渲染过程总的来说是这样的：Layout -》 Paint -》 Composite Layers</p>
<p><strong>我们说DOM会进行分层，那么什么元素会独立成层呢？</strong></p>
<hr>
<p>根元素、position、transfrom、半透明元素、CSS滤镜、Video 、Overflow</p>
<p><strong>我们说GPU跑起来会比CPU快，那么哪些元素属性会让GPU参与进来呢？</strong></p>
<hr>
<p>CSS3D、Video、Webgl(<a href="https://github.com/lgwebdream/gpu.js)、CSS滤镜、transfrom" target="_blank" rel="noopener">https://github.com/lgwebdream/gpu.js)、CSS滤镜、transfrom</a></p>
<p><strong>CPU和GPU到底有什么区别呢？</strong></p>
<hr>
<p><a href="https://www.zhihu.com/question/19903344" target="_blank" rel="noopener">https://www.zhihu.com/question/19903344</a></p>
<p>CPU即中央处理器，GPU即图形处理器。其次，要解释两者的区别，要先明白两者的相同之处：两者都有总线和外界联系，有自己的缓存体系，以及数字和逻辑运算单元。一句话，两者都为了完成计算任务而设计。</p>
<p>总结一下：<br>相同之处：总线和外界联系、缓存体系、数字和逻辑与预算单元、计算而生<br>不同之处：CPU主要负责和操作系统应用程序，GPU显示数据相关<br><a href="http://www.sohu.com/a/200435336_463987" target="_blank" rel="noopener">http://www.sohu.com/a/200435336_463987</a><br>还要推一推gpu.js这个库<br><a href="https://github.com/gpujs/gpu.js" target="_blank" rel="noopener">https://github.com/gpujs/gpu.js</a><br>GPU.js is a JavaScript Acceleration library for GPGPU (General purpose computing on GPUs) in JavaScript. GPU.js will automatically compile simple JavaScript functions into shader language and run them on the GPU. In case a GPU is not available, the functions will still run in regular JavaScript.<br>也就是说GPU.js会自动的将简单的js函数翻译成shader 语言并放在GPU上面运行他们。</p>
<p><strong>像素管道</strong></p>
<p>像素管道是网页性能优化的灵魂，让我们来看看什么是像素管道</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7728915-38abae3c3b147604.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>上图就是像素管道，通常我们会使用JS修改一些样式，随后浏览器会进行样式计算，然后进行布局，绘制，最后将各个图层合并在一起完成整个渲染的流程，这期间的每一步都有可能导致页面卡顿。</p>
<p>注意，并不是所有的样式改动都需要经历这五个步骤。举例来说：如果在JS中修改了元素的几何属性（宽度、高度等），那么浏览器需要需要将这五个步骤都走一遍。但如果您只是修改了文字的颜色，则布局（Layout）是可以跳过去的。</p>
<p>除了最后的合成，前面四个步骤在不同的场景下都可以被跳过。例如：CSS动画就可以跳过JS运算，它不需要执行JS。</p>
<p>通过录制performance我们可以看到主线程的任务。<br>我们可以放大主线程从而精准的看到每一帧浏览器都执行了哪些任务以及每个任务耗费了多长时间。如下图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7728915-ccc533f996af39c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><strong>我们如何改进上面的代码呢，减少重绘呢？</strong></p>
<p>使用transform来代替top和left</p>
<p>我们可以看到<a href="https://csstriggers.com/transform上面对于transform的描述是" target="_blank" rel="noopener">https://csstriggers.com/transform上面对于transform的描述是</a><br>Changing transform does not trigger any geometry changes or painting, which is very good. This means that the operation can likely be carried out by the compositor thread with the help of the GPU.<br>也就是说改变transform并不会触发几何图形的更改或者重绘，transform的操作可以合成器线程在GPU的帮助下执行。</p>
<p>css-triggers给出了不同的CSS属性被更改后会触发像素管道的那些步骤。<br>简单来说，像素管道经历的步骤越多，渲染时间就越长，单个步骤内也可能因为某个原因而变得耗时很长。</p>
<p>将上面代码的keyframes部分更改成：</p>
<pre><code>0%{
    transform: translate(0)
}
25%{
    transform: translate(200px,0)
}
50%{
    transform: translate(200px,200px)
}
75%{
    transform: translate(0,200px)
}
</code></pre><p>我们此时看到小球在运动，但是已经没有绿色了，已经没有重排了！！<br><img src="https://upload-images.jianshu.io/upload_images/7728915-738f7a03a027261e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>神奇！！！<br>我们再来看看录制的summary<br><img src="https://upload-images.jianshu.io/upload_images/7728915-9d3f312090e615b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>我的天呐！真神奇。换了transforms每次运动就不用重绘重排了，都是合成层和GPU在操作了，而且只要GPU开启，速度就会快很多。<br><a href="https://csstriggers.com/这个网站拿好不送！！！" target="_blank" rel="noopener">https://csstriggers.com/这个网站拿好不送！！！</a></p>
<p><strong>总结</strong><br>CSS动画我们可以通过降低绘制区域并且使transform属性来完成动画，同时我们需要管理好图层，因为绘制和图层管理都需要成本，通常我们需要根据具体情况进行权衡并做出最好的选择。</p>
<h4 id="重排"><a href="#重排" class="headerlink" title="重排"></a>重排</h4><p><strong>什么会引起重排？</strong></p>
<hr>
<ol>
<li>添加或者删除元素的时候</li>
<li>元素的位置发生改变</li>
<li>元素的-webkit-box-sizing: border-box;不会让我们的盒子发生太多的变化<br>如果用标准盒子模型的话，盒子越来越大</li>
<li>页面初始化</li>
<li>内容变化（没有撑开盒）</li>
<li>js 读取一下几个值 offset、scroll、width、getComputerStyle<br>为什么js读取的时候会引起重排？</li>
</ol>
<pre><code>var ele = document.getElementById(&apos;myDiv&apos;);
ele.style.borderLeft = &apos;1px&apos;;
ele.style.borderRight = &apos;2px&apos;;
ele.style.padding = &apos;5px&apos;;
</code></pre><p>乍一想，元素的样式改变了三次，每次改变都会引起重排和重绘，所以总共有三次重排重绘过程，但是浏览器并不会这么笨，它会把三次修改“保存”起来<strong>（大多数浏览器通过队列化修改并批量执行来优化重排过程），一次完成</strong>！但是，有些时候你可能会（经常是不知不觉）强制刷新队列并要求计划任务立即执行。获取布局信息的操作会导致队列刷新，比如：</p>
<ul>
<li>offsetTop, offsetLeft, offsetWidth, offsetHeight</li>
<li>scrollTop, scrollLeft, scrollWidth, scrollHeight</li>
<li>clientTop, clientLeft, clientWidth, clientHeight</li>
<li><p>getComputedStyle() (currentStyle in IE)<br>将上面的代码稍加修改，</p>
<pre><code>var ele = document.getElementById(&apos;myDiv&apos;);
ele.style.borderLeft = &apos;1px&apos;;
ele.style.borderRight = &apos;2px&apos;;

// here use offsetHeight
// ...
ele.style.padding = &apos;5px&apos;;
</code></pre><p>因为offsetHeight属性需要返回最新的布局信息，因此浏览器不得不执行渲染队列中的“待处理变化”并触发重排以返回正确的值（即使队列中改变的样式属性和想要获取的属性值并没有什么关系），所以上面的代码，前两次的操作会缓存在渲染队列中待处理，但是一旦offsetHeight属性被请求了，队列就会立即执行，所以总共有两次重排与重绘。所以尽量不要在布局信息改变时做查询。</p>
</li>
</ul>
<p>我们可以使用requestAnimationFrame，拆开来写，就给了浏览器优化的机会了。</p>
<pre><code>var ele = document.getElementById(&apos;myDiv&apos;);
// here use offsetHeight
// ...
requestAnimationFrame(function(){
    ele.style.padding = &apos;5px&apos;;
    ele.style.borderLeft = &apos;1px&apos;;
    ele.style.borderRight = &apos;2px&apos;;
})
</code></pre><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame</a><br>requestAnimationFrame告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行</p>
<h4 id="页面加载性能优化"><a href="#页面加载性能优化" class="headerlink" title="页面加载性能优化"></a>页面加载性能优化</h4><p><strong>必须知道的概念</strong><br>TTFB（Time To First Byte ）：⾸字节时间<br>FP（First Paint ）：⾸次绘制，仅有⼀个div根节点。<br>FCP（First Contentful Paint）： ⾸次有内容的绘制，包含⻚⾯的基本框架，但没有数据内容。<br>FMP（First Meaningful Paint）：⾸次有意义的绘制，包含⻚⾯所有元素及数据<br>TTI（Time To Interactive）：可交互时间<br>Long tasks：超过了 50ms 的任务<br>SSR&amp;&amp;CSR：服务端渲染和客户端渲染<br>Isomorphic JavaScript：同构化<br><img src="https://upload-images.jianshu.io/upload_images/7728915-678d01015d49ce3e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><img src="https://upload-images.jianshu.io/upload_images/7728915-a2858fc9f537e9e8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><img src="https://upload-images.jianshu.io/upload_images/7728915-ac18413b9a12c429.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="FCP.png"><br><img src="https://upload-images.jianshu.io/upload_images/7728915-9961fad98a6f88d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="FMP.png"><br>类比于VUE<br><img src="https://upload-images.jianshu.io/upload_images/7728915-cef80b97d04fada4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>created  类比于  FP(首次绘制，只有一个app空节点)<br>mounted  类比于 FMP（页面基本框架绘制完成）</p>
<p><strong>Performance — 前端性能监控利器</strong><br>Performance是一个做前端性能监控离不开的API，最好在页面完全加载完成之后再使用，因为很多值必须在页面完全加载之后才能得到。最简单的办法是在window.onload事件中读取各种数据。<br><a href="https://www.cnblogs.com/bldxh/p/6857324.html" target="_blank" rel="noopener">https://www.cnblogs.com/bldxh/p/6857324.html</a><br><a href="https://cloud.tencent.com/developer/news/301840" target="_blank" rel="noopener">https://cloud.tencent.com/developer/news/301840</a><br>从输入url到用户可以使用页面的全过程时间统计，会返回一个PerformanceTiming对象，单位均为毫秒。<br><img src="https://upload-images.jianshu.io/upload_images/7728915-fa17cdb1b727a8a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>每一个performance.timing属性都表示一个页面事件（例如页面发送了请求）或者页面加载（例如当DOM开始加载），测量以毫秒的形式从1970年1月1日的午夜开始。结果为0表示该事件未发生（例如redirectEnd或者redirectStart等）<br><img src="https://upload-images.jianshu.io/upload_images/7728915-1e0712aa04594799.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>其中有个方法叫<code>getEntries()</code><br>获取所有资源请求的时间数据,这个函数返回一个按startTime排序的对象数组，数组成员除了会自动根据所请求资源的变化而改变以外，还可以用mark(),measure()方法自定义添加，该对象的属性中除了包含资源加载时间还有以下五个属性。<br>name：资源名称，是资源的绝对路径或调用mark方法自定义的名称<br>startTime:开始时间<br>duration：加载时间<br>entryType：资源类型，entryType类型不同数组中的对象结构也不同！具体见下<br>initiatorType：谁发起的请求，具体见下<br>话不多说，咱们来写写代码。</p>
<pre><code>&lt;style&gt;
body{
    background-color: greenyellow;
}
&lt;/style&gt;

const obsever = new PerformanceObserver((list)=&gt;{
    for(const entry of list.getEntries()){
        console.log(entry.entryType);
        console.log(entry.startTime);
        console.log(entry.duration);
    }
})

obsever.observe({entryTypes:[&apos;paint&apos;]});
</code></pre><p>结果如下：<br><img src="https://upload-images.jianshu.io/upload_images/7728915-cdb151163a57a5cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>或者可以直接通过window.performance.getEntriesByType(“paint”)就可以取得FP和FCP的值</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7728915-11139bc0a3285d2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>FMP主要用来给页面打点。</p>
<p><strong>五分钟撸一个前端性能监控工具</strong><br><a href="http://web.jobbole.com/94938/" target="_blank" rel="noopener">http://web.jobbole.com/94938/</a></p>
<p><strong>聊聊performance中的long task</strong><br>什么是 <code>long task</code>?<br><img src="https://upload-images.jianshu.io/upload_images/7728915-dc3b5932f032f7d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><a href="https://www.itcodemonkey.com/article/10654.html" target="_blank" rel="noopener">https://www.itcodemonkey.com/article/10654.html</a></p>
<p>简单而言，任何在浏览器中执行超过 50 ms 的任务，都是 <code>long task</code>。</p>
<p>那么 <code>long task</code>这个时间是怎么得来的？<br>因为浏览器是单线程，这意味着同一时间主线程只能处理一个任务，如果一个任务执行时间太长，浏览器就无法执行其他任务，用户就会感觉浏览器被卡死，因为他的输入得不到任何响应。</p>
<p>为了100ms内能给出相应，将空闲周期执行的任务限制在50ms意味着，即使用户的输入行为发生在任务刚执行时。浏览器仍有50ms来相应用户的输入。</p>
<p>long task 会长时间占据主线程资源，进而阻碍了其他关键任务的执行/响应，造成页面卡顿。</p>
<p>常见场景如：</p>
<p>不断计算 DOM 元素的大小、位置，并且根据结果对页面进行 relayout；</p>
<p>一次性生成十分庞大的 DOM 元素，如大型表单；</p>
<p>1000000次的循环计算；</p>
<p><code>long task</code>的基本属性<br>Long Tasks API 定义了 <code>PerformanceLongTaskTiming</code>接口，用于描述 <code>long task</code>。<br>一般而言，name + attribution 就可以基本定位出 long task 的来源：</p>
<p><code>name</code>：告诉我们来源是 <script> 还是 <iframe/> ？self -&gt; <script/>；same-origin-xxx + cross-origin-xxx -&gt; <iframe/></p>
<p><code>attribution</code>：到底是哪个 <iframe/>？</p>
<p>如何使用？</p>
<pre><code>const obsever = new PerformanceObserver((list)=&gt;{
    for(const entry of list.getEntries()){
        console.log(entry.entryType);
        console.log(entry.startTime);
        console.log(entry.duration);
        console.log(JSON.stringify(entry.attribution))
    }
})

obsever.observe({entryTypes:[&apos;longtask&apos;]});
</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/7728915-1f663fac7ec42e4f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><strong>还发现了一篇不错的文章，前端性能优化标准</strong><a href="https://yq.aliyun.com/articles/598162">https://yq.aliyun.com/articles/598162</a></p>
<p><strong>CSR SSR 预渲染 同构的优点和缺点</strong><br><img src="https://upload-images.jianshu.io/upload_images/7728915-e8d07c802a942636.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h4 id="NodeJs性能优化"><a href="#NodeJs性能优化" class="headerlink" title="NodeJs性能优化"></a>NodeJs性能优化</h4><p><strong>什么是内存泄漏？</strong><br>不再用到的变量/内存，没有及时释放，就叫做内存泄漏。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7728915-7e01d7747e7ac6f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><strong>内存泄漏的表现</strong><br>随着内存泄漏的增长，V8对垃圾收集器越来越具有攻击性，这会使你的应用运行速度变慢。</p>
<p>内存泄漏可能触发其他类型的失败，可能会耗尽文件描述符，还可能会突然不能建立新的数据库连接。</p>
<p><strong>压力测试寻找内存泄漏</strong><br><a href="https://www.cnblogs.com/ycyzharry/p/8372168.html">https://www.cnblogs.com/ycyzharry/p/8372168.html</a><br><a href="https://github.com/wg/wrk">https://github.com/wg/wrk</a><br><strong>wrk</strong>支持大多数类UNIX系统，不支持windows。</p>
<p>还有更专业的JMeter</p>
<p><strong>查找node内存泄漏工具</strong><br>memwatch + heapdump</p>
<p>如果不发生特别大的内存泄漏问题，这两个工具是不会跳出来的。</p>
<pre><code>memwatch.on(&apos;leak&apos;,function(info){
    var file = &apos;./tmp/heapsnapshot&apos;;
    heapdump.writeSnapshot(file,function(err){
        if(err)console.log(err);
        else console.error(&apos;Wrote snapshot&apos;,file);
    })
})

//通过Diff的方式找到真正的元凶

var hd = new memwatch.HeapDiff();
var diff = hd.end()

//一个状态时间发射器
memwatch.on(&apos;stats&apos;,function(stats){
    //数据包括
    usage_trend(使用趋势)
    current_base(当前基数)
    estimated_base(预期基数)
    num_full_gc(完整的垃圾回收次数)
    num_inc_gc(增长的垃圾回收次数)
    heap_compactions(内存压缩次数)
    min(最小)
    max(最大)
})
</code></pre><p><a href="http://www.linkdata.se/sourcecode/memwatch/">http://www.linkdata.se/sourcecode/memwatch/</a>   memwatch的源代码下载地址</p>
<h4 id="Nodejs编码规范"><a href="#Nodejs编码规范" class="headerlink" title="Nodejs编码规范"></a>Nodejs编码规范</h4><hr>
<h5 id="慎用内存缓存"><a href="#慎用内存缓存" class="headerlink" title="慎用内存缓存"></a>慎用内存缓存</h5><p>函数内的变量是可以随着函数执行被回收的，但是全局不行。所以避免使用对象作为缓存，可以移步到Redis等。</p>
<p><code>Redis</code> 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。</p>
<p><code>Redis</code> 与其他 key - value 缓存产品有以下三个特点：</p>
<p><code>Redis</code>支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。<br><code>Redis</code>不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。<br><code>Redis</code>支持数据的备份，即master-slave模式的数据备份。</p>
<p><a href="http://www.runoob.com/redis/redis-intro.html">http://www.runoob.com/redis/redis-intro.html</a></p>
<h5 id="关于队列消费不及时"><a href="#关于队列消费不及时" class="headerlink" title="关于队列消费不及时"></a>关于队列消费不及时</h5><p>比如我们用log4来收集日志，如果日志的产生速度大于文件写入的速度。就容易产生内存泄漏。访问已经结束了，服务器的log4日志还在不停的写。<br>解决方式：<br>监控队列的长度一旦堆积就报警或者拒绝新的要求。<br>所以的异步调用都有超时回调，一旦达到时间调用未得到结果就报警。</p>
<h5 id="关于闭包"><a href="#关于闭包" class="headerlink" title="关于闭包"></a>关于闭包</h5><p>node如果有闭包从而产生内存泄露服务器就很容易挂，相对于在浏览器的js的闭包，node的闭包的处理显得更加重要。</p>
<p>解决方式：</p>
<ol>
<li>weakmap可以立即回收某个变量。</li>
</ol>
<pre><code>let b = new Object()
let wm = new Weakmap()
wm.set(b,new Array(5*1024*1024))
b = null
</code></pre><ol start="2">
<li>perf_hooks（性能钩子）<br>是nodejs中的一个api。<blockquote>
<p>The Performance Timing API provides an implementation of the <a href="http://nodejs.cn/s/ds56gw">W3C Performance Timeline</a> specification. The purpose of the API is to support collection of high resolution performance metrics. This is the same Performance API as implemented in modern Web browsers.<br><strong>提供的功能就类似于JS中的那个new PerformanceObserver</strong></p>
</blockquote>
</li>
</ol>
<pre><code>const obs = new PerformanceObserver((items) =&gt; {
    console.log(items.getEntries()[0].duration);
    performance.clearMarks();
});
obs.observe({ entryTypes: [&apos;measure&apos;] });

performance.mark(&apos;A&apos;);
doSomeLongRunningProcess(() =&gt; {
    performance.mark(&apos;B&apos;);
    performance.measure(&apos;A to B&apos;, &apos;A&apos;, &apos;B&apos;);
});
</code></pre><p>详细内容参照<a href="http://nodejs.cn/api/perf_hooks.html">http://nodejs.cn/api/perf_hooks.html</a></p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>对于nodejs应用的测试</p>
<ol>
<li>node –inspect app.js</li>
<li>chrome://inspect/#devices</li>
<li>没经过压力测试的代码只完成10%</li>
<li>准确计算QPS未雨绸缪</li>
<li>合理利用压力测试工具</li>
<li>注意缓存队列及其他耗时较长的代码</li>
<li>开发健壮的NodeJs应用</li>
</ol>
</script></p>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/13/性能优化启示录/" data-id="ck35ybx6l000jnrh2cin5jkhj" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JS基础/">JS基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JS资源/">JS资源</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/京城一灯/">京城一灯</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/京城一灯第一章/">京城一灯第一章</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/京城一灯第二章/">京城一灯第二章</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/11/10/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2019/06/09/HTTP协议那些事-0/">HTTP协议那些事</a>
          </li>
        
          <li>
            <a href="/2019/06/08/JS语言精粹/">JS语言精粹</a>
          </li>
        
          <li>
            <a href="/2019/03/29/Arguments对象/">Arguments对象</a>
          </li>
        
          <li>
            <a href="/2019/03/23/前端学习资源-1/">前端学习资源</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Tency<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>