<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.8.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="Tency的博客" type="application/atom+xml">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="需要掌握的语法const,let推荐使用const因为  const可以提醒大家，不能被改变 const比较符合函数式编程 与let 本质的区别，在于编译器内部的处理机制也不同js编译器有对const进行优化。  对象解构http://es6.ruanyifeng.com/#docs/destructuring function test(){     return {         a:&amp;qu">
<meta property="og:type" content="article">
<meta property="og:title" content="ES6学习笔记">
<meta property="og:url" content="http://yoursite.com/posts/38921/index.html">
<meta property="og:site_name" content="Tency的博客">
<meta property="og:description" content="需要掌握的语法const,let推荐使用const因为  const可以提醒大家，不能被改变 const比较符合函数式编程 与let 本质的区别，在于编译器内部的处理机制也不同js编译器有对const进行优化。  对象解构http://es6.ruanyifeng.com/#docs/destructuring function test(){     return {         a:&amp;qu">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7728915-5975c77c3c29683e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7728915-49d0523515bec2b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7728915-26f6acc81449cc3d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7728915-c51a71183ac93db6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:updated_time" content="2020-01-29T08:50:09.636Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ES6学习笔记">
<meta name="twitter:description" content="需要掌握的语法const,let推荐使用const因为  const可以提醒大家，不能被改变 const比较符合函数式编程 与let 本质的区别，在于编译器内部的处理机制也不同js编译器有对const进行优化。  对象解构http://es6.ruanyifeng.com/#docs/destructuring function test(){     return {         a:&amp;qu">
<meta name="twitter:image" content="https://upload-images.jianshu.io/upload_images/7728915-5975c77c3c29683e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">

<link rel="canonical" href="http://yoursite.com/posts/38921/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>ES6学习笔记 | Tency的博客</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?62b62399680e8c0fa1e9bd39ad08bf38";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Tency的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/posts/38921/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Tency">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tency的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          ES6学习笔记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-03-12 20:43:11" itemprop="dateCreated datePublished" datetime="2019-03-12T20:43:11+08:00">2019-03-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-01-29 16:50:09" itemprop="dateModified" datetime="2020-01-29T16:50:09+08:00">2020-01-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/京城一灯/" itemprop="url" rel="index">
                    <span itemprop="name">京城一灯</span>
                  </a>
                </span>
            </span>

          
            <span id="/posts/38921/" class="post-meta-item leancloud_visitors" data-flag-title="ES6学习笔记" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/posts/38921/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/posts/38921/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="需要掌握的语法"><a href="#需要掌握的语法" class="headerlink" title="需要掌握的语法"></a>需要掌握的语法</h2><h3 id="const-let"><a href="#const-let" class="headerlink" title="const,let"></a>const,let</h3><p>推荐使用const<br>因为</p>
<ol>
<li>const可以提醒大家，不能被改变</li>
<li>const比较符合函数式编程</li>
<li>与let 本质的区别，在于编译器内部的处理机制也不同<br>js编译器有对const进行优化。</li>
</ol>
<h5 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h5><p><a href="http://es6.ruanyifeng.com/#docs/destructuring" target="_blank" rel="noopener">http://es6.ruanyifeng.com/#docs/destructuring</a></p>
<pre><code>function test(){
    return {
        a:&quot;Hello&quot;,
        b:&quot;World&quot;,
        age:&quot;100&quot;
    }
}
const result = test();
const {a,age,b} = result;
console.log(a); //Hello
console.log(b); //World&quot;
console.log(age); //100
</code></pre><p><strong>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</strong></p>
<pre><code>let {zty1,zty2}={
    zty1:&quot;aaa&quot;,
    zty2:&quot;bbb&quot;
}
console.log(zty1);
console.log(zty2);
</code></pre><p>其实对象的解构赋值其实是下面这种形式的简写。</p>
<pre><code>let { foo: foo, bar: bar } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };
</code></pre><p>也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。</p>
<pre><code>let { foo: baz } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };
baz // &quot;aaa&quot;
foo // error: foo is not defined
</code></pre><p><code>baz</code>才是要被赋值的变量而不是<code>foo</code><br>如果解构不成功，变量的值就等于<code>undefined</code>。<br>如果等号的右边不是数组（或者严格地说，不是可遍历的结构，参见《Iterator》一章），那么将会报错。<br>//下面的将会报错</p>
<pre><code>let [foo] = 1;
let [foo] = false;
let [foo] = NaN;
let [foo] = undefined;
let [foo] = null;
let [foo] = {};
</code></pre><p>  对于 Set 结构，也可以使用数组的解构赋值。</p>
<pre><code>let [j,k,l] = new Set([&apos;a&apos;,&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]);
console.log(j,k,l)//a,b,c
</code></pre><p><strong>解构赋值允许指定默认值。</strong></p>
<p><strong>应用</strong></p>
<ol>
<li><p>交换变量的值</p>
<pre><code>let x = 1;
let y = 2;
[x,y] = [y,x];
console.log(&apos;x&apos;,x);  //x,2
console.log(&apos;y&apos;,y);  //y,1
</code></pre><p>上面代码交换变量 <code>x</code>和<code>y</code>的值，这样的写法不仅简洁，而且易读，语义非常清晰。</p>
</li>
<li><p>从函数返回多个值<br>函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。</p>
<pre><code>function test(){
    return [1,2,3];
}
let [a,b,c] = test();
console.log(a,b,c);// 1 2 3
</code></pre><ol start="3">
<li><p>提取 JSON 数据<br>解构赋值对提取 JSON 对象中的数据，尤其有用。</p>
<p>  let jsonData = {</p>
<pre><code>&apos;age&apos;: 16,
&apos;name&apos;: &apos;jack&apos;,
&apos;data&apos;: [1,2]
</code></pre><p>  }</p>
<p>  let {age,name,data:number} = jsonData;<br>  console.log(age);<br>  console.log(name);<br>  console.log(number);</p>
</li>
</ol>
</li>
<li><p>遍历 Map 结构const map = new Map();</p>
<pre><code>map.set(&apos;first&apos;, &apos;hello&apos;);
map.set(&apos;second&apos;, &apos;world&apos;);

for (let [key, value] of map) {
  console.log(key + &quot; is &quot; + value);
}
// first is hello
// second is world
</code></pre><p> 如果只想获取键名，或者只想获取键值，可以写成下面这样。</p>
</li>
</ol>
<pre><code>  // 获取键值
  for (let [,value] of map) {
    // ...
}
</code></pre><h5 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h5><pre><code>var a = &apos;hello&apos;;
var b = &quot;world&quot;;
var c = `我最爱的就是${a}${b}`
var d = test`我最爱的就是${a}${b}`;
function test(str,...value){
    console.log(str);
    console.log(value);
}
</code></pre><p>value是模板字符串里面的值。</p>
<h5 id="数组对象"><a href="#数组对象" class="headerlink" title="数组对象"></a>数组对象</h5><pre><code>const arr = &quot;888&quot;;
const arr1 = [&apos;花&apos;,&apos;大树&apos;,...arr];
console.log(arr1); //[&quot;花&quot;, &quot;大树&quot;, &quot;8&quot;, &quot;8&quot;, &quot;8&quot;]
</code></pre><p><strong>…扩展运算符</strong><br>构造字面量数组时使用展开语法会方便很多。</p>
<ul>
<li><p>将已有数组元素变成新数组的一部分</p>
<pre><code>var parts = [&apos;shoulders&apos;, &apos;knees&apos;]; 
var lyrics = [&apos;head&apos;, ...parts, &apos;and&apos;, &apos;toes&apos;]; 
// [&quot;head&quot;, &quot;shoulders&quot;, &quot;knees&quot;, &quot;and&quot;, &quot;toes&quot;]
</code></pre></li>
<li><p>数组拷贝（浅拷贝）</p>
<pre><code>var arr = [1,2,3];
var arr2 = [...arr];
arr2.push(4);
console.log(arr); //[ 1, 2, 3 ]
console.log(arr2); //[ 1, 2, 3 , 4]
</code></pre></li>
<li><p>连接数组<br>如果没有扩展运算符就用concat</p>
<pre><code>const arr1 = [1,2,3];
const arr2 = [4,5,6];
const arr3 = [...arr1,...arr2];
console.log(arr3); //[1, 2, 3, 4, 5, 6]
</code></pre><p>Array.unshift() 方法常用于在数组的开头插入新元素/数组.  不使用展开语法, 示例如下:</p>
<pre><code>var arr1 = [0, 1, 2];
arr2 = [3, 4, 5];
// 将 arr2 中的元素插入到 arr1 的开头
Array.prototype.unshift.apply(arr1, arr2) // arr1 现在是 [3, 4, 5, 0, 1, 2]
</code></pre></li>
</ul>
<p>如果是用扩展运算符，我们就可以</p>
<pre><code>var arr1 = [0, 1, 2];
var arr2 = [3, 4, 5];
arr1 = [...arr2, ...arr1];
</code></pre><p>但是需要注意的是，我们用展开语法创建了一个新的 arr1 数组，而unshift是在旧的arr1数组。</p>
<p><strong>Object.is()</strong></p>
<pre><code>console.log(NaN === NaN);//false
console.log(Object.is(NaN,NaN)); //true
</code></pre><p><strong>跟原型有关的一些操作</strong><br>Object.setPrototypeOf()方法设置一个指定的对象的原型 ( 即, 内部[[Prototype]]属性）到另一个对象或  <code>null</code>。<br>但是应该避免修改。应该使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create" title="Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。 （请打开浏览器控制台以查看运行结果。）" target="_blank" rel="noopener"><code>Object.create()</code></a>来创建带有你想要的<code>[[Prototype]]</code>的新对象。</p>
<pre><code>const eat = {
    getEat(){
        console.log(&apos;吃&apos;);
    }
}
const drink = {
    getDrink(){
        console.log(&apos;喝&apos;)
    }
}

let sunday = Object.create(eat);
Object.getPrototypeOf(sunday); //{getEat:f()}
//Object.getPrototypeOf返回指定对象的原型
sunday.getEat()//吃
Object.setPrototypeOf(sunday,drink);
sunday.getEat()//sunday.getEat() is not a function
sunday.getDrink();//喝
</code></pre><h5 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h5><p>箭头函数<br>作用：</p>
<ol>
<li>让代码更加简洁</li>
<li><p>绑定了父级的作用域<br>让我们看看这个困扰了我很久的代码</p>
<pre><code>const luke = {
    id: 2,
    say: function(){
        setTimeout(function(){
            console.log(this.id)
        },50)
    },
    sayWithThat: function(){
        let that = this
        setTimeout(function(){
            console.log(that.id)
        },500)
    },
    sayWithArrow: function(){
        setTimeout(() =&gt;{
            console.log(this.id)
        },1000)
    },
    sayWithGlobalArrow: ()=&gt;{
        setTimeout(()=&gt;{
            console.log(this.id)
        },2000)
    }
}
luke.say() //undefined 因为setTimeout运行时this指向的是window
luke.sayWithThat() //2 保存了定义时的that
luke.sayWithArrow() //2  箭头函数指向的是父级的作用域，也就是指向luke
luke.sayWithGlobalArrow() //undefined  注意这里是两个箭头函数
</code></pre><p>刚开始遇到了一个问题：</p>
<pre><code>sayWIthArrow: ()=&gt;{
    setTimeout(function(){
        console.log(this.id)
    })
}
</code></pre><p>本来预想的是2，但是输出结果却是undefined，为啥？？？</p>
</li>
</ol>
<p>因为我把方法写在了对象里，而对象的括号是不能封闭作用域的。所以此时的this还是指向全局对象。<br>所以，通过以上的错误可以提醒我们，<strong>最好不要用箭头函数作为对象的方法。</strong></p>
<p>然后我写了几个相关函数测试一下：当对象的函数用箭头函数的话会怎么样？</p>
<pre><code>//对象的函数最好不要用箭头函数
let person = {
    a:2,
    say:()=&gt;{
        console.log(this.a)
    },
    sayhh:function(){
        console.log(this.a)
    }
}
person.say() //undefined
person.sayhh() //2
</code></pre><p>可以看到，对象中的方法如果是箭头函数的话，他的作用域就会变成全局的。不然就是person。</p>
<pre><code>{var factory = function() {
this.a = &apos;a&apos;;
this.b = &apos;b&apos;;
this.c = {
  a: &apos;a+&apos;,
  b: function() {
    return this.a
   }
  }
 }

console.log(new factory().c.b());    //a+
};

{
var factory = function() {
this.a = &apos;a&apos;;
this.b = &apos;b&apos;;
this.c = {
  a: &apos;a+&apos;,
  b: () =&gt; {
    return this.a
  }
}
}
console.log(new factory().c.b());//a
}
</code></pre><p>还有这个例子，也让我困扰了很久，先看第一种情况，因为是c调用的b，所以this指向c，取得的a值就是a+<br>第二种情况，注意啊！this.c是个对象啊！{ }是不能封闭作用域的，函数才可以，所以this还是会指向外层的factory这个函数，所以是a</p>
<p>先让我们看看MDN上面的一个示例吧！</p>
<pre><code>//创建一个含有bar方法的obj对象
//bar返回一个函数
//这个函数返回this
//这个this永久绑定到了它外层函数的this，也就是obj
let obj = {
    bar:function(){
        var x = (()=&gt; this);
    return x;
    }
}

//作为obj对象的一个方法来调用bar,把它的this绑定到obj上
var fn = obj.bar();
//如果是非箭头函数的话，按照fn()这样再去调用的话this是指向全局的
//但是箭头函数早已经绑定了obj
console.log(fn() === obj);
</code></pre><h5 id="Generator-函数"><a href="#Generator-函数" class="headerlink" title="Generator 函数"></a>Generator 函数</h5><p>形式上，Generator 函数是一个普通函数，但是有两个特征。一是，function关键字与函数名之间有一个星号；二是，函数体内部使用yield表达式，定义不同的内部状态（yield在英语里的意思就是“产出”）</p>
<pre><code> let zty = function*(){
     yield &quot;哈哈&quot;;
     yield &quot;呵呵&quot;;
 }
 const result = zty();
 console.log(result.next());
 //{value: &quot;哈哈&quot;, done: false}
 console.log(result.next());
 //{value: &quot;呵呵&quot;, done: false}
 console.log(result.next());
//{value: undefined, done: true}
</code></pre><p>Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用 Generator 函数后，该函数并不执行，下一步，必须调用遍历器对象的next方法，使得指针移向下一个状态。<br><strong>ES6 没有规定，function关键字与函数名之间的星号，写在哪个位置。这导致下面的写法都能通过。</strong></p>
<h3 id="Set和map"><a href="#Set和map" class="headerlink" title="Set和map"></a>Set和map</h3><p>Set是一个构造函数，可以去遍历<br>Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p>
<p>Set本身是一个构造函数，用来生成 Set 数据结构。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7728915-5975c77c3c29683e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>一定要在日常开发中好好运用！！！！</p>
<h3 id="module"><a href="#module" class="headerlink" title="module"></a>module</h3><p><img src="https://upload-images.jianshu.io/upload_images/7728915-49d0523515bec2b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>上面是比较好的一种表现形式<br>system.js</p>
<h3 id="async和await"><a href="#async和await" class="headerlink" title="async和await"></a>async和await</h3><p><code>async</code> 函数是什么？一句话，它就是 Generator 函数的语法糖。async函数就是将 Generator 函数的星号（*）替换成 <code>async</code>，将yield替换成<code>await</code>。而且，<code>async</code>函数的执行，与普通函数一模一样，只要一行,就能得到最后结果。而Generator 函数，需要调用next方法，或者用co模块，才能真正执行，得到最后结果。<br>而且<code>async</code>表示函数里有异步操作，<code>await</code>表示紧跟在后面的表达式需要等待结果。<br> <code>async</code>函数的返回值是<code>Promise</code>对象，可以用then指定下一步操作。</p>
<pre><code>async function getPriceByName(name){
    const symbol = await getSymbol(name);
    const Price = await getPrice(symbol);
    return Price; 
}

getPriceByName(&apos;taobao&apos;).then(res=&gt;{
    console.log(res);
})
</code></pre><p>上面代码是一个获取股票报价的函数，<strong>函数前面的async关键字，表明该函数内部有异步操作。调用该函数时，会立即返回一个Promise对象。</strong></p>
<pre><code>function timeout(ms){
    return new Promise((resolve)=&gt;{
        setTimeout(resolve,ms)
    })
}

async function time(value,mm){
    const result = await timeout(mm);
    console.log(value);
}

time(&apos;解决&apos;,1000)
</code></pre><p>上面代码指定 50 毫秒以后，输出hello world。<br><img src="https://upload-images.jianshu.io/upload_images/7728915-26f6acc81449cc3d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="修饰器"><a href="#修饰器" class="headerlink" title="修饰器"></a>修饰器</h3><p>修饰器是一个对类进行处理的函数。修饰器函数的第一个参数，就是所要修饰的目标类。</p>
<pre><code>function testable(target) {
  // ...
}
</code></pre><p>testable函数的参数target，就是会被修饰的类。<br>React 与 Redux 库的源代码有用到这个东西。<br><a href="https://github.com/jayphelps/core-decorators.js" target="_blank" rel="noopener">core-decorators.js</a>是一个第三方模块，提供了几个常见的修饰器，通过它可以更好地理解修饰器。<br>（1）@autobind<br>autobind修饰器使得方法中的this对象，绑定原始对象。<br>（2）@readonly<br>readonly修饰器使得属性或方法不可写。<br>（3）@override<br>override修饰器检查子类的方法，是否正确覆盖了父类的同名方法，如果不正确会报错。</p>
<h3 id="Symbol-惟一的）"><a href="#Symbol-惟一的）" class="headerlink" title="Symbol(惟一的）"></a>Symbol(惟一的）</h3><p>Symbol 值可以显式转为字符串。Symbol 值不能与其他类型的值进行运算，会报错!</p>
<pre><code>let sym = Symbol(&apos;My symbol&apos;);

String(sym) // &apos;Symbol(My symbol)&apos;
sym.toString() // &apos;Symbol(My symbol)&apos;
</code></pre><p>s1和s2是两个 Symbol 值。如果不加参数，它们在控制台的输出都是Symbol()，不利于区分。有了参数以后，就等于为它们加上了描述，输出的时候就能够分清，到底是哪一个值。<br>        // 没有参数的情况<br>        let s1 = Symbol();<br>        let s2 = Symbol();</p>
<pre><code>s1 === s2 // false

// 有参数的情况
let s1 = Symbol(&apos;foo&apos;);
let s2 = Symbol(&apos;foo&apos;);

s1 === s2 // false
</code></pre><p>实例：消除魔术字符串<br>魔术字符串指的是，在代码之中多次出现、与代码形成强耦合的<strong>某一个具体的字符串或者数值</strong>。风格良好的代码，应该尽量消除魔术字符串，改由含义清晰的变量代替。</p>
<pre><code>function getArea(shape, options) {
  let area = 0;

  switch (shape) {
    case &apos;Triangle&apos;: // 魔术字符串
      area = .5 * options.width * options.height;
      break;
    /* ... more code ... */
  }

  return area;
}

getArea(&apos;Triangle&apos;, { width: 100, height: 100 }); // 魔术字符串
</code></pre><p>上面代码中，字符串Triangle就是一个魔术字符串。它多次出现，与代码形成“强耦合”，不利于将来的修改和维护。<br>常用的消除魔术字符串的方法，<strong>就是把它写成一个变量</strong>。</p>
<pre><code>const shapeType = {
  triangle: &apos;Triangle&apos;
};

function getArea(shape, options) {
  let area = 0;
  switch (shape) {
    case shapeType.triangle:
      area = .5 * options.width * options.height;
      break;
  }
  return area;
}

getArea(shapeType.triangle, { width: 100, height: 100 });
</code></pre><p>上面代码中，我们把Triangle写成shapeType对象的triangle属性，这样就消除了强耦合。</p>
<p>如果仔细分析，可以发现shapeType.triangle等于哪个值并不重要，只要确保不会跟其他shapeType属性的值冲突即可。因此，这里就很适合改用 Symbol 值。</p>
<pre><code>const shapeType = {
  triangle: Symbol()
};
</code></pre><h3 id="Iterator遍历器（迭代器）"><a href="#Iterator遍历器（迭代器）" class="headerlink" title="Iterator遍历器（迭代器）"></a>Iterator遍历器（迭代器）</h3><p>下面代码定义了一个遍历器：</p>
<pre><code>//生成器函数
function makeIterator(arr){
    let nextIndex = 0

    //return一个迭代器对象
    return{
        next:()=&gt;{
            if(nextIndex &lt; arr.length){
                return{value: arr[nextIndex++],done:false}
            }else{
                return {done:true}
            }
        }
    }
}

const it = makeIterator([&apos;吃饭&apos;,&apos;睡觉&apos;,&apos;打豆豆&apos;])
console.log(1,it.next().value);  // 1 吃饭
console.log(2,it.next().value);  // 2 睡觉
console.log(3,it.next().value);  // 3 打豆豆
console.log(4,it.next().value);  // 4 undefined
</code></pre><p>请记住这个简陋的遍历器。<br><strong>Iterator遍历器和Generator函数的关系是很密切的</strong></p>
<h3 id="Generator-函数（生成器）"><a href="#Generator-函数（生成器）" class="headerlink" title="Generator 函数（生成器）"></a>Generator 函数（生成器）</h3><p>形式上，Generator 函数是一个普通函数，但是有两个特征。一是，function关键字与函数名之间有一个星号；二是，函数体内部使用yield表达式，定义不同的内部状态（yield在英语里的意思就是“产出”）<br>看看跟上面有点类似的例子：</p>
<pre><code>//generator
function* makeIterator(arr){
    for(let i = 0; i &lt; arr.length; i++){
        yield arr[i]
    }
}

const gen =  makeIterator([&apos;吃饭&apos;,&apos;睡觉&apos;,&apos;打豆豆&apos;])
console.log(1,gen.next().value);  // 1 吃饭
console.log(2,gen.next().value);  // 2 睡觉
console.log(3,gen.next().value);  // 3 打豆豆
console.log(4,gen.next().done);  // 4 true  
</code></pre><p>与上面例子比较之后，我们发现了什么<br><strong>总结：生成器就是为更方便使用迭代器，它的特点就是简化掉迭代器（Interator）的组建过程（创建过程）</strong></p>
<p>再看看另一个例子</p>
<pre><code> let zty = function*(){
     yield &quot;哈哈&quot;;
     yield &quot;呵呵&quot;;
 }
 const result = zty();
 console.log(result.next());
 //{value: &quot;哈哈&quot;, done: false}
 console.log(result.next());
 //{value: &quot;呵呵&quot;, done: false}
 console.log(result.next());
//{value: undefined, done: true}
</code></pre><p>Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用 Generator 函数后，该函数并不执行，下一步，必须调用遍历器对象的next方法，使得指针移向下一个状态。<br><strong>ES6 没有规定，function关键字与函数名之间的星号，写在哪个位置。这导致下面的写法都能通过。</strong></p>
<h3 id="co库执行Promise和generator-function"><a href="#co库执行Promise和generator-function" class="headerlink" title="co库执行Promise和generator function"></a>co库执行Promise和generator function</h3><p>npm install co -D</p>
<pre><code>const co = require(&apos;co&apos;);
const fetch = require(&apos;node-fetch&apos;)

co(function *(){
    const res = yield fetch(&apos;https://api.douban.com/v2/movie/1291843&apos;)
    const movie = yield res.json()
    const summary = movie.summary

    console.log(summary)
})
</code></pre><p>用同步的方式来执行异步的过程。<br><strong>co让genrator实现了自动执行，不需要手动调用next,而且实现的效果就是当第一句代码执行完的时候才会执行第二句，当第二句执行完的时候才能执行第三句。</strong><br><img src="https://upload-images.jianshu.io/upload_images/7728915-c51a71183ac93db6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<pre><code>//自己来实现一个简易的co
function run(generator){
    //调用generator来生成一个迭代器
    const iterator = generator()
    //执行第一个yield后面的内容
    const it = iterator.next()
    //fetch得到了一个promise
    const promise = it.value

    //将取得的data传入promise中
    //继续next
    promise.then(data =&gt; {
        const it2 = iterator.next(data)
        const promise2 = it2.value

        promise2.then(data2 =&gt; {
            iterator.next(data2)
        })

    })
}

run(function *(){
    const res = yield fetch(&apos;https://api.douban.com/v2/movie/1291843&apos;)
    const movie = yield res.json()
    const summary = movie.summary

    console.log(summary)
})
</code></pre><p>打印出来的结果一样。<br>当然，你可以去看看co的源代码！！<br>小tips：co库中yield后面不能跟着字符串或者布尔值<br>只能跟着function, promise, generator, array, or object</p>

    </div>

    
    
    

      <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
                <a href="/posts/5688/" rel="prev" title="性能优化启示录">
                  性能优化启示录 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="comments"></div>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#需要掌握的语法"><span class="nav-number">1.</span> <span class="nav-text">需要掌握的语法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#const-let"><span class="nav-number">1.1.</span> <span class="nav-text">const,let</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#对象解构"><span class="nav-number">1.1.0.1.</span> <span class="nav-text">对象解构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#模板字符串"><span class="nav-number">1.1.0.2.</span> <span class="nav-text">模板字符串</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#数组对象"><span class="nav-number">1.1.0.3.</span> <span class="nav-text">数组对象</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#函数"><span class="nav-number">1.1.0.4.</span> <span class="nav-text">函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Generator-函数"><span class="nav-number">1.1.0.5.</span> <span class="nav-text">Generator 函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Set和map"><span class="nav-number">1.2.</span> <span class="nav-text">Set和map</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#module"><span class="nav-number">1.3.</span> <span class="nav-text">module</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#async和await"><span class="nav-number">1.4.</span> <span class="nav-text">async和await</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#修饰器"><span class="nav-number">1.5.</span> <span class="nav-text">修饰器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Symbol-惟一的）"><span class="nav-number">1.6.</span> <span class="nav-text">Symbol(惟一的）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Iterator遍历器（迭代器）"><span class="nav-number">1.7.</span> <span class="nav-text">Iterator遍历器（迭代器）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Generator-函数（生成器）"><span class="nav-number">1.8.</span> <span class="nav-text">Generator 函数（生成器）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#co库执行Promise和generator-function"><span class="nav-number">1.9.</span> <span class="nav-text">co库执行Promise和generator function</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Tency</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Tency</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.8.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.5.0
  </div>

        






  <script>
  function leancloudSelector(url) {
    return document.getElementById(url).querySelector('.leancloud-visitors-count');
  }
  if (CONFIG.page.isPost) {
    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = visitors.getAttribute('id').trim();
      var title = visitors.getAttribute('data-flag-title').trim();

      Counter('get', `/classes/Counter?where=${JSON.stringify({ url })}`)
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .then(response => response.json())
              .then(() => {
                leancloudSelector(url).innerText = counter.time + 1;
              })
              .catch(error => {
                console.log('Failed to save visitor count', error);
              })
          } else {
              Counter('post', '/classes/Counter', { title: title, url: url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.log('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.log('LeanCloud Counter Error', error);
        });
    }
  } else {
    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return element.getAttribute('id').trim();
      });

      Counter('get', `/classes/Counter?where=${JSON.stringify({ url: { '$in': entries } })}`)
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length === 0) {
            document.querySelectorAll('.leancloud_visitors .leancloud-visitors-count').forEach(element => {
              element.innerText = 0;
            });
            return;
          }
          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.url;
            var time = item.time;
            leancloudSelector(url).innerText = time;
          }
          for (var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = leancloudSelector(url);
            if (element.innerText == '') {
              element.innerText = 0;
            }
          }
        })
        .catch(error => {
          console.log('LeanCloud Counter Error', error);
        });
    }
  }

  fetch('https://app-router.leancloud.cn/2/route?appId=Qlp8YnCN10nhru8jdUlnFJcw-gzGzoHsz')
    .then(response => response.json())
    .then(({ api_server }) => {
      var Counter = (method, url, data) => {
        return fetch(`https://${api_server}/1.1${url}`, {
          method: method,
          headers: {
            'X-LC-Id': 'Qlp8YnCN10nhru8jdUlnFJcw-gzGzoHsz',
            'X-LC-Key': 'pdpv2EtDmoHYwI6kjMOseApq',
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        const localhost = /http:\/\/(localhost|127.0.0.1|0.0.0.0)/;
        if (localhost.test(document.URL)) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    });
  </script>






        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  
















  

  


<script>
NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(item => {
    return GUEST.includes(item);
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: 'Qlp8YnCN10nhru8jdUlnFJcw-gzGzoHsz',
    appKey: 'pdpv2EtDmoHYwI6kjMOseApq',
    placeholder: "Just go go",
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: '' || 'zh-cn',
    path: location.pathname,
    recordIP: false,
    serverURLs: ''
  });
}, window.Valine);
</script>

</body>
</html>
